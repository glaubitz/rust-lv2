/* automatically generated by rust-bindgen 0.62.0 */

pub const LV2_ATOM_URI: &[u8; 30usize] = b"http://lv2plug.in/ns/ext/atom\0";
pub const LV2_ATOM_PREFIX: &[u8; 31usize] = b"http://lv2plug.in/ns/ext/atom#\0";
pub const LV2_ATOM__Atom: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/atom#Atom\0";
pub const LV2_ATOM__AtomPort: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/atom#AtomPort\0";
pub const LV2_ATOM__Blank: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/atom#Blank\0";
pub const LV2_ATOM__Bool: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/atom#Bool\0";
pub const LV2_ATOM__Chunk: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/atom#Chunk\0";
pub const LV2_ATOM__Double: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/atom#Double\0";
pub const LV2_ATOM__Event: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/atom#Event\0";
pub const LV2_ATOM__Float: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/atom#Float\0";
pub const LV2_ATOM__Int: &[u8; 34usize] = b"http://lv2plug.in/ns/ext/atom#Int\0";
pub const LV2_ATOM__Literal: &[u8; 38usize] = b"http://lv2plug.in/ns/ext/atom#Literal\0";
pub const LV2_ATOM__Long: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/atom#Long\0";
pub const LV2_ATOM__Number: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/atom#Number\0";
pub const LV2_ATOM__Object: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/atom#Object\0";
pub const LV2_ATOM__Path: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/atom#Path\0";
pub const LV2_ATOM__Property: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/atom#Property\0";
pub const LV2_ATOM__Resource: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/atom#Resource\0";
pub const LV2_ATOM__Sequence: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/atom#Sequence\0";
pub const LV2_ATOM__Sound: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/atom#Sound\0";
pub const LV2_ATOM__String: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/atom#String\0";
pub const LV2_ATOM__Tuple: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/atom#Tuple\0";
pub const LV2_ATOM__URI: &[u8; 34usize] = b"http://lv2plug.in/ns/ext/atom#URI\0";
pub const LV2_ATOM__URID: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/atom#URID\0";
pub const LV2_ATOM__Vector: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/atom#Vector\0";
pub const LV2_ATOM__atomTransfer: &[u8; 43usize] = b"http://lv2plug.in/ns/ext/atom#atomTransfer\0";
pub const LV2_ATOM__beatTime: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/atom#beatTime\0";
pub const LV2_ATOM__bufferType: &[u8; 41usize] = b"http://lv2plug.in/ns/ext/atom#bufferType\0";
pub const LV2_ATOM__childType: &[u8; 40usize] = b"http://lv2plug.in/ns/ext/atom#childType\0";
pub const LV2_ATOM__eventTransfer: &[u8; 44usize] =
    b"http://lv2plug.in/ns/ext/atom#eventTransfer\0";
pub const LV2_ATOM__frameTime: &[u8; 40usize] = b"http://lv2plug.in/ns/ext/atom#frameTime\0";
pub const LV2_ATOM__supports: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/atom#supports\0";
pub const LV2_ATOM__timeUnit: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/atom#timeUnit\0";
pub const LV2_ATOM_REFERENCE_TYPE: u32 = 0;
pub const LV2_URID_URI: &[u8; 30usize] = b"http://lv2plug.in/ns/ext/urid\0";
pub const LV2_URID_PREFIX: &[u8; 31usize] = b"http://lv2plug.in/ns/ext/urid#\0";
pub const LV2_URID__map: &[u8; 34usize] = b"http://lv2plug.in/ns/ext/urid#map\0";
pub const LV2_URID__unmap: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/urid#unmap\0";
pub const LV2_URID_MAP_URI: &[u8; 34usize] = b"http://lv2plug.in/ns/ext/urid#map\0";
pub const LV2_URID_UNMAP_URI: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/urid#unmap\0";
pub const LV2_BUF_SIZE_URI: &[u8; 34usize] = b"http://lv2plug.in/ns/ext/buf-size\0";
pub const LV2_BUF_SIZE_PREFIX: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/buf-size#\0";
pub const LV2_BUF_SIZE__boundedBlockLength: &[u8; 53usize] =
    b"http://lv2plug.in/ns/ext/buf-size#boundedBlockLength\0";
pub const LV2_BUF_SIZE__coarseBlockLength: &[u8; 52usize] =
    b"http://lv2plug.in/ns/ext/buf-size#coarseBlockLength\0";
pub const LV2_BUF_SIZE__fixedBlockLength: &[u8; 51usize] =
    b"http://lv2plug.in/ns/ext/buf-size#fixedBlockLength\0";
pub const LV2_BUF_SIZE__maxBlockLength: &[u8; 49usize] =
    b"http://lv2plug.in/ns/ext/buf-size#maxBlockLength\0";
pub const LV2_BUF_SIZE__minBlockLength: &[u8; 49usize] =
    b"http://lv2plug.in/ns/ext/buf-size#minBlockLength\0";
pub const LV2_BUF_SIZE__nominalBlockLength: &[u8; 53usize] =
    b"http://lv2plug.in/ns/ext/buf-size#nominalBlockLength\0";
pub const LV2_BUF_SIZE__powerOf2BlockLength: &[u8; 54usize] =
    b"http://lv2plug.in/ns/ext/buf-size#powerOf2BlockLength\0";
pub const LV2_BUF_SIZE__sequenceSize: &[u8; 47usize] =
    b"http://lv2plug.in/ns/ext/buf-size#sequenceSize\0";
pub const LV2_CORE_URI: &[u8; 29usize] = b"http://lv2plug.in/ns/lv2core\0";
pub const LV2_CORE_PREFIX: &[u8; 30usize] = b"http://lv2plug.in/ns/lv2core#\0";
pub const LV2_CORE__AllpassPlugin: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#AllpassPlugin\0";
pub const LV2_CORE__AmplifierPlugin: &[u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#AmplifierPlugin\0";
pub const LV2_CORE__AnalyserPlugin: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#AnalyserPlugin\0";
pub const LV2_CORE__AudioPort: &[u8; 39usize] = b"http://lv2plug.in/ns/lv2core#AudioPort\0";
pub const LV2_CORE__BandpassPlugin: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#BandpassPlugin\0";
pub const LV2_CORE__CVPort: &[u8; 36usize] = b"http://lv2plug.in/ns/lv2core#CVPort\0";
pub const LV2_CORE__ChorusPlugin: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#ChorusPlugin\0";
pub const LV2_CORE__CombPlugin: &[u8; 40usize] = b"http://lv2plug.in/ns/lv2core#CombPlugin\0";
pub const LV2_CORE__CompressorPlugin: &[u8; 46usize] =
    b"http://lv2plug.in/ns/lv2core#CompressorPlugin\0";
pub const LV2_CORE__ConstantPlugin: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#ConstantPlugin\0";
pub const LV2_CORE__ControlPort: &[u8; 41usize] = b"http://lv2plug.in/ns/lv2core#ControlPort\0";
pub const LV2_CORE__ConverterPlugin: &[u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#ConverterPlugin\0";
pub const LV2_CORE__DelayPlugin: &[u8; 41usize] = b"http://lv2plug.in/ns/lv2core#DelayPlugin\0";
pub const LV2_CORE__DistortionPlugin: &[u8; 46usize] =
    b"http://lv2plug.in/ns/lv2core#DistortionPlugin\0";
pub const LV2_CORE__DynamicsPlugin: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#DynamicsPlugin\0";
pub const LV2_CORE__EQPlugin: &[u8; 38usize] = b"http://lv2plug.in/ns/lv2core#EQPlugin\0";
pub const LV2_CORE__EnvelopePlugin: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#EnvelopePlugin\0";
pub const LV2_CORE__ExpanderPlugin: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#ExpanderPlugin\0";
pub const LV2_CORE__ExtensionData: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#ExtensionData\0";
pub const LV2_CORE__Feature: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#Feature\0";
pub const LV2_CORE__FilterPlugin: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#FilterPlugin\0";
pub const LV2_CORE__FlangerPlugin: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#FlangerPlugin\0";
pub const LV2_CORE__FunctionPlugin: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#FunctionPlugin\0";
pub const LV2_CORE__GatePlugin: &[u8; 40usize] = b"http://lv2plug.in/ns/lv2core#GatePlugin\0";
pub const LV2_CORE__GeneratorPlugin: &[u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#GeneratorPlugin\0";
pub const LV2_CORE__HighpassPlugin: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#HighpassPlugin\0";
pub const LV2_CORE__InputPort: &[u8; 39usize] = b"http://lv2plug.in/ns/lv2core#InputPort\0";
pub const LV2_CORE__InstrumentPlugin: &[u8; 46usize] =
    b"http://lv2plug.in/ns/lv2core#InstrumentPlugin\0";
pub const LV2_CORE__LimiterPlugin: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#LimiterPlugin\0";
pub const LV2_CORE__LowpassPlugin: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#LowpassPlugin\0";
pub const LV2_CORE__MixerPlugin: &[u8; 41usize] = b"http://lv2plug.in/ns/lv2core#MixerPlugin\0";
pub const LV2_CORE__ModulatorPlugin: &[u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#ModulatorPlugin\0";
pub const LV2_CORE__MultiEQPlugin: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#MultiEQPlugin\0";
pub const LV2_CORE__OscillatorPlugin: &[u8; 46usize] =
    b"http://lv2plug.in/ns/lv2core#OscillatorPlugin\0";
pub const LV2_CORE__OutputPort: &[u8; 40usize] = b"http://lv2plug.in/ns/lv2core#OutputPort\0";
pub const LV2_CORE__ParaEQPlugin: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#ParaEQPlugin\0";
pub const LV2_CORE__PhaserPlugin: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#PhaserPlugin\0";
pub const LV2_CORE__PitchPlugin: &[u8; 41usize] = b"http://lv2plug.in/ns/lv2core#PitchPlugin\0";
pub const LV2_CORE__Plugin: &[u8; 36usize] = b"http://lv2plug.in/ns/lv2core#Plugin\0";
pub const LV2_CORE__PluginBase: &[u8; 40usize] = b"http://lv2plug.in/ns/lv2core#PluginBase\0";
pub const LV2_CORE__Point: &[u8; 35usize] = b"http://lv2plug.in/ns/lv2core#Point\0";
pub const LV2_CORE__Port: &[u8; 34usize] = b"http://lv2plug.in/ns/lv2core#Port\0";
pub const LV2_CORE__PortProperty: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#PortProperty\0";
pub const LV2_CORE__Resource: &[u8; 38usize] = b"http://lv2plug.in/ns/lv2core#Resource\0";
pub const LV2_CORE__ReverbPlugin: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#ReverbPlugin\0";
pub const LV2_CORE__ScalePoint: &[u8; 40usize] = b"http://lv2plug.in/ns/lv2core#ScalePoint\0";
pub const LV2_CORE__SimulatorPlugin: &[u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#SimulatorPlugin\0";
pub const LV2_CORE__SpatialPlugin: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#SpatialPlugin\0";
pub const LV2_CORE__Specification: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#Specification\0";
pub const LV2_CORE__SpectralPlugin: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#SpectralPlugin\0";
pub const LV2_CORE__UtilityPlugin: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#UtilityPlugin\0";
pub const LV2_CORE__WaveshaperPlugin: &[u8; 46usize] =
    b"http://lv2plug.in/ns/lv2core#WaveshaperPlugin\0";
pub const LV2_CORE__appliesTo: &[u8; 39usize] = b"http://lv2plug.in/ns/lv2core#appliesTo\0";
pub const LV2_CORE__binary: &[u8; 36usize] = b"http://lv2plug.in/ns/lv2core#binary\0";
pub const LV2_CORE__connectionOptional: &[u8; 48usize] =
    b"http://lv2plug.in/ns/lv2core#connectionOptional\0";
pub const LV2_CORE__control: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#control\0";
pub const LV2_CORE__default: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#default\0";
pub const LV2_CORE__designation: &[u8; 41usize] = b"http://lv2plug.in/ns/lv2core#designation\0";
pub const LV2_CORE__documentation: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#documentation\0";
pub const LV2_CORE__enabled: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#enabled\0";
pub const LV2_CORE__enumeration: &[u8; 41usize] = b"http://lv2plug.in/ns/lv2core#enumeration\0";
pub const LV2_CORE__extensionData: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#extensionData\0";
pub const LV2_CORE__freeWheeling: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#freeWheeling\0";
pub const LV2_CORE__hardRTCapable: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#hardRTCapable\0";
pub const LV2_CORE__inPlaceBroken: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#inPlaceBroken\0";
pub const LV2_CORE__index: &[u8; 35usize] = b"http://lv2plug.in/ns/lv2core#index\0";
pub const LV2_CORE__integer: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#integer\0";
pub const LV2_CORE__isLive: &[u8; 36usize] = b"http://lv2plug.in/ns/lv2core#isLive\0";
pub const LV2_CORE__latency: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#latency\0";
pub const LV2_CORE__maximum: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#maximum\0";
pub const LV2_CORE__microVersion: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#microVersion\0";
pub const LV2_CORE__minimum: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#minimum\0";
pub const LV2_CORE__minorVersion: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#minorVersion\0";
pub const LV2_CORE__name: &[u8; 34usize] = b"http://lv2plug.in/ns/lv2core#name\0";
pub const LV2_CORE__optionalFeature: &[u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#optionalFeature\0";
pub const LV2_CORE__port: &[u8; 34usize] = b"http://lv2plug.in/ns/lv2core#port\0";
pub const LV2_CORE__portProperty: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#portProperty\0";
pub const LV2_CORE__project: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#project\0";
pub const LV2_CORE__prototype: &[u8; 39usize] = b"http://lv2plug.in/ns/lv2core#prototype\0";
pub const LV2_CORE__reportsLatency: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#reportsLatency\0";
pub const LV2_CORE__requiredFeature: &[u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#requiredFeature\0";
pub const LV2_CORE__sampleRate: &[u8; 40usize] = b"http://lv2plug.in/ns/lv2core#sampleRate\0";
pub const LV2_CORE__scalePoint: &[u8; 40usize] = b"http://lv2plug.in/ns/lv2core#scalePoint\0";
pub const LV2_CORE__symbol: &[u8; 36usize] = b"http://lv2plug.in/ns/lv2core#symbol\0";
pub const LV2_CORE__toggled: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#toggled\0";
pub const LV2_DATA_ACCESS_URI: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/data-access\0";
pub const LV2_DATA_ACCESS_PREFIX: &[u8; 38usize] = b"http://lv2plug.in/ns/ext/data-access#\0";
pub const LV2_DYN_MANIFEST_URI: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/dynmanifest\0";
pub const LV2_DYN_MANIFEST_PREFIX: &[u8; 38usize] = b"http://lv2plug.in/ns/ext/dynmanifest#\0";
pub const LV2_EVENT_URI: &[u8; 31usize] = b"http://lv2plug.in/ns/ext/event\0";
pub const LV2_EVENT_PREFIX: &[u8; 32usize] = b"http://lv2plug.in/ns/ext/event#\0";
pub const LV2_EVENT__Event: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/event#Event\0";
pub const LV2_EVENT__EventPort: &[u8; 41usize] = b"http://lv2plug.in/ns/ext/event#EventPort\0";
pub const LV2_EVENT__FrameStamp: &[u8; 42usize] = b"http://lv2plug.in/ns/ext/event#FrameStamp\0";
pub const LV2_EVENT__TimeStamp: &[u8; 41usize] = b"http://lv2plug.in/ns/ext/event#TimeStamp\0";
pub const LV2_EVENT__generatesTimeStamp: &[u8; 50usize] =
    b"http://lv2plug.in/ns/ext/event#generatesTimeStamp\0";
pub const LV2_EVENT__generic: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/event#generic\0";
pub const LV2_EVENT__inheritsEvent: &[u8; 45usize] =
    b"http://lv2plug.in/ns/ext/event#inheritsEvent\0";
pub const LV2_EVENT__inheritsTimeStamp: &[u8; 49usize] =
    b"http://lv2plug.in/ns/ext/event#inheritsTimeStamp\0";
pub const LV2_EVENT__supportsEvent: &[u8; 45usize] =
    b"http://lv2plug.in/ns/ext/event#supportsEvent\0";
pub const LV2_EVENT__supportsTimeStamp: &[u8; 49usize] =
    b"http://lv2plug.in/ns/ext/event#supportsTimeStamp\0";
pub const LV2_EVENT_AUDIO_STAMP: u32 = 0;
pub const LV2_INSTANCE_ACCESS_URI: &[u8; 41usize] = b"http://lv2plug.in/ns/ext/instance-access\0";
pub const LV2_LOG_URI: &[u8; 29usize] = b"http://lv2plug.in/ns/ext/log\0";
pub const LV2_LOG_PREFIX: &[u8; 30usize] = b"http://lv2plug.in/ns/ext/log#\0";
pub const LV2_LOG__Entry: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/log#Entry\0";
pub const LV2_LOG__Error: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/log#Error\0";
pub const LV2_LOG__Note: &[u8; 34usize] = b"http://lv2plug.in/ns/ext/log#Note\0";
pub const LV2_LOG__Trace: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/log#Trace\0";
pub const LV2_LOG__Warning: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/log#Warning\0";
pub const LV2_LOG__log: &[u8; 33usize] = b"http://lv2plug.in/ns/ext/log#log\0";
pub const LV2_MIDI_URI: &[u8; 30usize] = b"http://lv2plug.in/ns/ext/midi\0";
pub const LV2_MIDI_PREFIX: &[u8; 31usize] = b"http://lv2plug.in/ns/ext/midi#\0";
pub const LV2_MIDI__ActiveSense: &[u8; 42usize] = b"http://lv2plug.in/ns/ext/midi#ActiveSense\0";
pub const LV2_MIDI__Aftertouch: &[u8; 41usize] = b"http://lv2plug.in/ns/ext/midi#Aftertouch\0";
pub const LV2_MIDI__Bender: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/midi#Bender\0";
pub const LV2_MIDI__ChannelPressure: &[u8; 46usize] =
    b"http://lv2plug.in/ns/ext/midi#ChannelPressure\0";
pub const LV2_MIDI__Chunk: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/midi#Chunk\0";
pub const LV2_MIDI__Clock: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/midi#Clock\0";
pub const LV2_MIDI__Continue: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/midi#Continue\0";
pub const LV2_MIDI__Controller: &[u8; 41usize] = b"http://lv2plug.in/ns/ext/midi#Controller\0";
pub const LV2_MIDI__MidiEvent: &[u8; 40usize] = b"http://lv2plug.in/ns/ext/midi#MidiEvent\0";
pub const LV2_MIDI__NoteOff: &[u8; 38usize] = b"http://lv2plug.in/ns/ext/midi#NoteOff\0";
pub const LV2_MIDI__NoteOn: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/midi#NoteOn\0";
pub const LV2_MIDI__ProgramChange: &[u8; 44usize] =
    b"http://lv2plug.in/ns/ext/midi#ProgramChange\0";
pub const LV2_MIDI__QuarterFrame: &[u8; 43usize] = b"http://lv2plug.in/ns/ext/midi#QuarterFrame\0";
pub const LV2_MIDI__Reset: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/midi#Reset\0";
pub const LV2_MIDI__SongPosition: &[u8; 43usize] = b"http://lv2plug.in/ns/ext/midi#SongPosition\0";
pub const LV2_MIDI__SongSelect: &[u8; 41usize] = b"http://lv2plug.in/ns/ext/midi#SongSelect\0";
pub const LV2_MIDI__Start: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/midi#Start\0";
pub const LV2_MIDI__Stop: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/midi#Stop\0";
pub const LV2_MIDI__SystemCommon: &[u8; 43usize] = b"http://lv2plug.in/ns/ext/midi#SystemCommon\0";
pub const LV2_MIDI__SystemExclusive: &[u8; 46usize] =
    b"http://lv2plug.in/ns/ext/midi#SystemExclusive\0";
pub const LV2_MIDI__SystemMessage: &[u8; 44usize] =
    b"http://lv2plug.in/ns/ext/midi#SystemMessage\0";
pub const LV2_MIDI__SystemRealtime: &[u8; 45usize] =
    b"http://lv2plug.in/ns/ext/midi#SystemRealtime\0";
pub const LV2_MIDI__Tick: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/midi#Tick\0";
pub const LV2_MIDI__TuneRequest: &[u8; 42usize] = b"http://lv2plug.in/ns/ext/midi#TuneRequest\0";
pub const LV2_MIDI__VoiceMessage: &[u8; 43usize] = b"http://lv2plug.in/ns/ext/midi#VoiceMessage\0";
pub const LV2_MIDI__benderValue: &[u8; 42usize] = b"http://lv2plug.in/ns/ext/midi#benderValue\0";
pub const LV2_MIDI__binding: &[u8; 38usize] = b"http://lv2plug.in/ns/ext/midi#binding\0";
pub const LV2_MIDI__byteNumber: &[u8; 41usize] = b"http://lv2plug.in/ns/ext/midi#byteNumber\0";
pub const LV2_MIDI__channel: &[u8; 38usize] = b"http://lv2plug.in/ns/ext/midi#channel\0";
pub const LV2_MIDI__chunk: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/midi#chunk\0";
pub const LV2_MIDI__controllerNumber: &[u8; 47usize] =
    b"http://lv2plug.in/ns/ext/midi#controllerNumber\0";
pub const LV2_MIDI__controllerValue: &[u8; 46usize] =
    b"http://lv2plug.in/ns/ext/midi#controllerValue\0";
pub const LV2_MIDI__noteNumber: &[u8; 41usize] = b"http://lv2plug.in/ns/ext/midi#noteNumber\0";
pub const LV2_MIDI__pressure: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/midi#pressure\0";
pub const LV2_MIDI__programNumber: &[u8; 44usize] =
    b"http://lv2plug.in/ns/ext/midi#programNumber\0";
pub const LV2_MIDI__property: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/midi#property\0";
pub const LV2_MIDI__songNumber: &[u8; 41usize] = b"http://lv2plug.in/ns/ext/midi#songNumber\0";
pub const LV2_MIDI__songPosition: &[u8; 43usize] = b"http://lv2plug.in/ns/ext/midi#songPosition\0";
pub const LV2_MIDI__status: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/midi#status\0";
pub const LV2_MIDI__statusMask: &[u8; 41usize] = b"http://lv2plug.in/ns/ext/midi#statusMask\0";
pub const LV2_MIDI__velocity: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/midi#velocity\0";
pub const LV2_MORPH_URI: &[u8; 31usize] = b"http://lv2plug.in/ns/ext/morph\0";
pub const LV2_MORPH_PREFIX: &[u8; 32usize] = b"http://lv2plug.in/ns/ext/morph#\0";
pub const LV2_MORPH__AutoMorphPort: &[u8; 45usize] =
    b"http://lv2plug.in/ns/ext/morph#AutoMorphPort\0";
pub const LV2_MORPH__MorphPort: &[u8; 41usize] = b"http://lv2plug.in/ns/ext/morph#MorphPort\0";
pub const LV2_MORPH__interface: &[u8; 41usize] = b"http://lv2plug.in/ns/ext/morph#interface\0";
pub const LV2_MORPH__supportsType: &[u8; 44usize] =
    b"http://lv2plug.in/ns/ext/morph#supportsType\0";
pub const LV2_MORPH__currentType: &[u8; 43usize] = b"http://lv2plug.in/ns/ext/morph#currentType\0";
pub const LV2_OPTIONS_URI: &[u8; 33usize] = b"http://lv2plug.in/ns/ext/options\0";
pub const LV2_OPTIONS_PREFIX: &[u8; 34usize] = b"http://lv2plug.in/ns/ext/options#\0";
pub const LV2_OPTIONS__Option: &[u8; 40usize] = b"http://lv2plug.in/ns/ext/options#Option\0";
pub const LV2_OPTIONS__interface: &[u8; 43usize] = b"http://lv2plug.in/ns/ext/options#interface\0";
pub const LV2_OPTIONS__options: &[u8; 41usize] = b"http://lv2plug.in/ns/ext/options#options\0";
pub const LV2_OPTIONS__requiredOption: &[u8; 48usize] =
    b"http://lv2plug.in/ns/ext/options#requiredOption\0";
pub const LV2_OPTIONS__supportedOption: &[u8; 49usize] =
    b"http://lv2plug.in/ns/ext/options#supportedOption\0";
pub const LV2_PARAMETERS_URI: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/parameters\0";
pub const LV2_PARAMETERS_PREFIX: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/parameters#\0";
pub const LV2_PARAMETERS__CompressorControls: &[u8; 55usize] =
    b"http://lv2plug.in/ns/ext/parameters#CompressorControls\0";
pub const LV2_PARAMETERS__ControlGroup: &[u8; 49usize] =
    b"http://lv2plug.in/ns/ext/parameters#ControlGroup\0";
pub const LV2_PARAMETERS__EnvelopeControls: &[u8; 53usize] =
    b"http://lv2plug.in/ns/ext/parameters#EnvelopeControls\0";
pub const LV2_PARAMETERS__FilterControls: &[u8; 51usize] =
    b"http://lv2plug.in/ns/ext/parameters#FilterControls\0";
pub const LV2_PARAMETERS__OscillatorControls: &[u8; 55usize] =
    b"http://lv2plug.in/ns/ext/parameters#OscillatorControls\0";
pub const LV2_PARAMETERS__amplitude: &[u8; 46usize] =
    b"http://lv2plug.in/ns/ext/parameters#amplitude\0";
pub const LV2_PARAMETERS__attack: &[u8; 43usize] = b"http://lv2plug.in/ns/ext/parameters#attack\0";
pub const LV2_PARAMETERS__bypass: &[u8; 43usize] = b"http://lv2plug.in/ns/ext/parameters#bypass\0";
pub const LV2_PARAMETERS__cutoffFrequency: &[u8; 52usize] =
    b"http://lv2plug.in/ns/ext/parameters#cutoffFrequency\0";
pub const LV2_PARAMETERS__decay: &[u8; 42usize] = b"http://lv2plug.in/ns/ext/parameters#decay\0";
pub const LV2_PARAMETERS__delay: &[u8; 42usize] = b"http://lv2plug.in/ns/ext/parameters#delay\0";
pub const LV2_PARAMETERS__dryLevel: &[u8; 45usize] =
    b"http://lv2plug.in/ns/ext/parameters#dryLevel\0";
pub const LV2_PARAMETERS__frequency: &[u8; 46usize] =
    b"http://lv2plug.in/ns/ext/parameters#frequency\0";
pub const LV2_PARAMETERS__gain: &[u8; 41usize] = b"http://lv2plug.in/ns/ext/parameters#gain\0";
pub const LV2_PARAMETERS__hold: &[u8; 41usize] = b"http://lv2plug.in/ns/ext/parameters#hold\0";
pub const LV2_PARAMETERS__pulseWidth: &[u8; 47usize] =
    b"http://lv2plug.in/ns/ext/parameters#pulseWidth\0";
pub const LV2_PARAMETERS__ratio: &[u8; 42usize] = b"http://lv2plug.in/ns/ext/parameters#ratio\0";
pub const LV2_PARAMETERS__release: &[u8; 44usize] =
    b"http://lv2plug.in/ns/ext/parameters#release\0";
pub const LV2_PARAMETERS__resonance: &[u8; 46usize] =
    b"http://lv2plug.in/ns/ext/parameters#resonance\0";
pub const LV2_PARAMETERS__sampleRate: &[u8; 47usize] =
    b"http://lv2plug.in/ns/ext/parameters#sampleRate\0";
pub const LV2_PARAMETERS__sustain: &[u8; 44usize] =
    b"http://lv2plug.in/ns/ext/parameters#sustain\0";
pub const LV2_PARAMETERS__threshold: &[u8; 46usize] =
    b"http://lv2plug.in/ns/ext/parameters#threshold\0";
pub const LV2_PARAMETERS__waveform: &[u8; 45usize] =
    b"http://lv2plug.in/ns/ext/parameters#waveform\0";
pub const LV2_PARAMETERS__wetDryRatio: &[u8; 48usize] =
    b"http://lv2plug.in/ns/ext/parameters#wetDryRatio\0";
pub const LV2_PARAMETERS__wetLevel: &[u8; 45usize] =
    b"http://lv2plug.in/ns/ext/parameters#wetLevel\0";
pub const LV2_PATCH_URI: &[u8; 31usize] = b"http://lv2plug.in/ns/ext/patch\0";
pub const LV2_PATCH_PREFIX: &[u8; 32usize] = b"http://lv2plug.in/ns/ext/patch#\0";
pub const LV2_PATCH__Ack: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/patch#Ack\0";
pub const LV2_PATCH__Delete: &[u8; 38usize] = b"http://lv2plug.in/ns/ext/patch#Delete\0";
pub const LV2_PATCH__Copy: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/patch#Copy\0";
pub const LV2_PATCH__Error: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/patch#Error\0";
pub const LV2_PATCH__Get: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/patch#Get\0";
pub const LV2_PATCH__Message: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/patch#Message\0";
pub const LV2_PATCH__Move: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/patch#Move\0";
pub const LV2_PATCH__Patch: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/patch#Patch\0";
pub const LV2_PATCH__Post: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/patch#Post\0";
pub const LV2_PATCH__Put: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/patch#Put\0";
pub const LV2_PATCH__Request: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/patch#Request\0";
pub const LV2_PATCH__Response: &[u8; 40usize] = b"http://lv2plug.in/ns/ext/patch#Response\0";
pub const LV2_PATCH__Set: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/patch#Set\0";
pub const LV2_PATCH__accept: &[u8; 38usize] = b"http://lv2plug.in/ns/ext/patch#accept\0";
pub const LV2_PATCH__add: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/patch#add\0";
pub const LV2_PATCH__body: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/patch#body\0";
pub const LV2_PATCH__context: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/patch#context\0";
pub const LV2_PATCH__destination: &[u8; 43usize] = b"http://lv2plug.in/ns/ext/patch#destination\0";
pub const LV2_PATCH__property: &[u8; 40usize] = b"http://lv2plug.in/ns/ext/patch#property\0";
pub const LV2_PATCH__readable: &[u8; 40usize] = b"http://lv2plug.in/ns/ext/patch#readable\0";
pub const LV2_PATCH__remove: &[u8; 38usize] = b"http://lv2plug.in/ns/ext/patch#remove\0";
pub const LV2_PATCH__request: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/patch#request\0";
pub const LV2_PATCH__subject: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/patch#subject\0";
pub const LV2_PATCH__sequenceNumber: &[u8; 46usize] =
    b"http://lv2plug.in/ns/ext/patch#sequenceNumber\0";
pub const LV2_PATCH__value: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/patch#value\0";
pub const LV2_PATCH__wildcard: &[u8; 40usize] = b"http://lv2plug.in/ns/ext/patch#wildcard\0";
pub const LV2_PATCH__writable: &[u8; 40usize] = b"http://lv2plug.in/ns/ext/patch#writable\0";
pub const LV2_PORT_GROUPS_URI: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/port-groups\0";
pub const LV2_PORT_GROUPS_PREFIX: &[u8; 38usize] = b"http://lv2plug.in/ns/ext/port-groups#\0";
pub const LV2_PORT_GROUPS__DiscreteGroup: &[u8; 51usize] =
    b"http://lv2plug.in/ns/ext/port-groups#DiscreteGroup\0";
pub const LV2_PORT_GROUPS__Element: &[u8; 45usize] =
    b"http://lv2plug.in/ns/ext/port-groups#Element\0";
pub const LV2_PORT_GROUPS__FivePointOneGroup: &[u8; 55usize] =
    b"http://lv2plug.in/ns/ext/port-groups#FivePointOneGroup\0";
pub const LV2_PORT_GROUPS__FivePointZeroGroup: &[u8; 56usize] =
    b"http://lv2plug.in/ns/ext/port-groups#FivePointZeroGroup\0";
pub const LV2_PORT_GROUPS__FourPointZeroGroup: &[u8; 56usize] =
    b"http://lv2plug.in/ns/ext/port-groups#FourPointZeroGroup\0";
pub const LV2_PORT_GROUPS__Group: &[u8; 43usize] = b"http://lv2plug.in/ns/ext/port-groups#Group\0";
pub const LV2_PORT_GROUPS__InputGroup: &[u8; 48usize] =
    b"http://lv2plug.in/ns/ext/port-groups#InputGroup\0";
pub const LV2_PORT_GROUPS__MidSideGroup: &[u8; 50usize] =
    b"http://lv2plug.in/ns/ext/port-groups#MidSideGroup\0";
pub const LV2_PORT_GROUPS__MonoGroup: &[u8; 47usize] =
    b"http://lv2plug.in/ns/ext/port-groups#MonoGroup\0";
pub const LV2_PORT_GROUPS__OutputGroup: &[u8; 49usize] =
    b"http://lv2plug.in/ns/ext/port-groups#OutputGroup\0";
pub const LV2_PORT_GROUPS__SevenPointOneGroup: &[u8; 56usize] =
    b"http://lv2plug.in/ns/ext/port-groups#SevenPointOneGroup\0";
pub const LV2_PORT_GROUPS__SevenPointOneWideGroup: &[u8; 60usize] =
    b"http://lv2plug.in/ns/ext/port-groups#SevenPointOneWideGroup\0";
pub const LV2_PORT_GROUPS__SixPointOneGroup: &[u8; 54usize] =
    b"http://lv2plug.in/ns/ext/port-groups#SixPointOneGroup\0";
pub const LV2_PORT_GROUPS__StereoGroup: &[u8; 49usize] =
    b"http://lv2plug.in/ns/ext/port-groups#StereoGroup\0";
pub const LV2_PORT_GROUPS__ThreePointZeroGroup: &[u8; 57usize] =
    b"http://lv2plug.in/ns/ext/port-groups#ThreePointZeroGroup\0";
pub const LV2_PORT_GROUPS__center: &[u8; 44usize] =
    b"http://lv2plug.in/ns/ext/port-groups#center\0";
pub const LV2_PORT_GROUPS__centerLeft: &[u8; 48usize] =
    b"http://lv2plug.in/ns/ext/port-groups#centerLeft\0";
pub const LV2_PORT_GROUPS__centerRight: &[u8; 49usize] =
    b"http://lv2plug.in/ns/ext/port-groups#centerRight\0";
pub const LV2_PORT_GROUPS__element: &[u8; 45usize] =
    b"http://lv2plug.in/ns/ext/port-groups#element\0";
pub const LV2_PORT_GROUPS__group: &[u8; 43usize] = b"http://lv2plug.in/ns/ext/port-groups#group\0";
pub const LV2_PORT_GROUPS__left: &[u8; 42usize] = b"http://lv2plug.in/ns/ext/port-groups#left\0";
pub const LV2_PORT_GROUPS__lowFrequencyEffects: &[u8; 57usize] =
    b"http://lv2plug.in/ns/ext/port-groups#lowFrequencyEffects\0";
pub const LV2_PORT_GROUPS__mainInput: &[u8; 47usize] =
    b"http://lv2plug.in/ns/ext/port-groups#mainInput\0";
pub const LV2_PORT_GROUPS__mainOutput: &[u8; 48usize] =
    b"http://lv2plug.in/ns/ext/port-groups#mainOutput\0";
pub const LV2_PORT_GROUPS__rearCenter: &[u8; 48usize] =
    b"http://lv2plug.in/ns/ext/port-groups#rearCenter\0";
pub const LV2_PORT_GROUPS__rearLeft: &[u8; 46usize] =
    b"http://lv2plug.in/ns/ext/port-groups#rearLeft\0";
pub const LV2_PORT_GROUPS__rearRight: &[u8; 47usize] =
    b"http://lv2plug.in/ns/ext/port-groups#rearRight\0";
pub const LV2_PORT_GROUPS__right: &[u8; 43usize] = b"http://lv2plug.in/ns/ext/port-groups#right\0";
pub const LV2_PORT_GROUPS__side: &[u8; 42usize] = b"http://lv2plug.in/ns/ext/port-groups#side\0";
pub const LV2_PORT_GROUPS__sideChainOf: &[u8; 49usize] =
    b"http://lv2plug.in/ns/ext/port-groups#sideChainOf\0";
pub const LV2_PORT_GROUPS__sideLeft: &[u8; 46usize] =
    b"http://lv2plug.in/ns/ext/port-groups#sideLeft\0";
pub const LV2_PORT_GROUPS__sideRight: &[u8; 47usize] =
    b"http://lv2plug.in/ns/ext/port-groups#sideRight\0";
pub const LV2_PORT_GROUPS__source: &[u8; 44usize] =
    b"http://lv2plug.in/ns/ext/port-groups#source\0";
pub const LV2_PORT_GROUPS__subGroupOf: &[u8; 48usize] =
    b"http://lv2plug.in/ns/ext/port-groups#subGroupOf\0";
pub const LV2_PORT_PROPS_URI: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/port-props\0";
pub const LV2_PORT_PROPS_PREFIX: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/port-props#\0";
pub const LV2_PORT_PROPS__causesArtifacts: &[u8; 52usize] =
    b"http://lv2plug.in/ns/ext/port-props#causesArtifacts\0";
pub const LV2_PORT_PROPS__continuousCV: &[u8; 49usize] =
    b"http://lv2plug.in/ns/ext/port-props#continuousCV\0";
pub const LV2_PORT_PROPS__discreteCV: &[u8; 47usize] =
    b"http://lv2plug.in/ns/ext/port-props#discreteCV\0";
pub const LV2_PORT_PROPS__displayPriority: &[u8; 52usize] =
    b"http://lv2plug.in/ns/ext/port-props#displayPriority\0";
pub const LV2_PORT_PROPS__expensive: &[u8; 46usize] =
    b"http://lv2plug.in/ns/ext/port-props#expensive\0";
pub const LV2_PORT_PROPS__hasStrictBounds: &[u8; 52usize] =
    b"http://lv2plug.in/ns/ext/port-props#hasStrictBounds\0";
pub const LV2_PORT_PROPS__logarithmic: &[u8; 48usize] =
    b"http://lv2plug.in/ns/ext/port-props#logarithmic\0";
pub const LV2_PORT_PROPS__notAutomatic: &[u8; 49usize] =
    b"http://lv2plug.in/ns/ext/port-props#notAutomatic\0";
pub const LV2_PORT_PROPS__notOnGUI: &[u8; 45usize] =
    b"http://lv2plug.in/ns/ext/port-props#notOnGUI\0";
pub const LV2_PORT_PROPS__rangeSteps: &[u8; 47usize] =
    b"http://lv2plug.in/ns/ext/port-props#rangeSteps\0";
pub const LV2_PORT_PROPS__supportsStrictBounds: &[u8; 57usize] =
    b"http://lv2plug.in/ns/ext/port-props#supportsStrictBounds\0";
pub const LV2_PORT_PROPS__trigger: &[u8; 44usize] =
    b"http://lv2plug.in/ns/ext/port-props#trigger\0";
pub const LV2_PRESETS_URI: &[u8; 33usize] = b"http://lv2plug.in/ns/ext/presets\0";
pub const LV2_PRESETS_PREFIX: &[u8; 34usize] = b"http://lv2plug.in/ns/ext/presets#\0";
pub const LV2_PRESETS__Bank: &[u8; 38usize] = b"http://lv2plug.in/ns/ext/presets#Bank\0";
pub const LV2_PRESETS__Preset: &[u8; 40usize] = b"http://lv2plug.in/ns/ext/presets#Preset\0";
pub const LV2_PRESETS__bank: &[u8; 38usize] = b"http://lv2plug.in/ns/ext/presets#bank\0";
pub const LV2_PRESETS__preset: &[u8; 40usize] = b"http://lv2plug.in/ns/ext/presets#preset\0";
pub const LV2_PRESETS__value: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/presets#value\0";
pub const LV2_RESIZE_PORT_URI: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/resize-port\0";
pub const LV2_RESIZE_PORT_PREFIX: &[u8; 38usize] = b"http://lv2plug.in/ns/ext/resize-port#\0";
pub const LV2_RESIZE_PORT__asLargeAs: &[u8; 47usize] =
    b"http://lv2plug.in/ns/ext/resize-port#asLargeAs\0";
pub const LV2_RESIZE_PORT__minimumSize: &[u8; 49usize] =
    b"http://lv2plug.in/ns/ext/resize-port#minimumSize\0";
pub const LV2_RESIZE_PORT__resize: &[u8; 44usize] =
    b"http://lv2plug.in/ns/ext/resize-port#resize\0";
pub const LV2_STATE_URI: &[u8; 31usize] = b"http://lv2plug.in/ns/ext/state\0";
pub const LV2_STATE_PREFIX: &[u8; 32usize] = b"http://lv2plug.in/ns/ext/state#\0";
pub const LV2_STATE__State: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/state#State\0";
pub const LV2_STATE__interface: &[u8; 41usize] = b"http://lv2plug.in/ns/ext/state#interface\0";
pub const LV2_STATE__loadDefaultState: &[u8; 48usize] =
    b"http://lv2plug.in/ns/ext/state#loadDefaultState\0";
pub const LV2_STATE__freePath: &[u8; 40usize] = b"http://lv2plug.in/ns/ext/state#freePath\0";
pub const LV2_STATE__makePath: &[u8; 40usize] = b"http://lv2plug.in/ns/ext/state#makePath\0";
pub const LV2_STATE__mapPath: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/state#mapPath\0";
pub const LV2_STATE__state: &[u8; 37usize] = b"http://lv2plug.in/ns/ext/state#state\0";
pub const LV2_STATE__threadSafeRestore: &[u8; 49usize] =
    b"http://lv2plug.in/ns/ext/state#threadSafeRestore\0";
pub const LV2_STATE__StateChanged: &[u8; 44usize] =
    b"http://lv2plug.in/ns/ext/state#StateChanged\0";
pub const LV2_TIME_URI: &[u8; 30usize] = b"http://lv2plug.in/ns/ext/time\0";
pub const LV2_TIME_PREFIX: &[u8; 31usize] = b"http://lv2plug.in/ns/ext/time#\0";
pub const LV2_TIME__Time: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/time#Time\0";
pub const LV2_TIME__Position: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/time#Position\0";
pub const LV2_TIME__Rate: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/time#Rate\0";
pub const LV2_TIME__position: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/time#position\0";
pub const LV2_TIME__barBeat: &[u8; 38usize] = b"http://lv2plug.in/ns/ext/time#barBeat\0";
pub const LV2_TIME__bar: &[u8; 34usize] = b"http://lv2plug.in/ns/ext/time#bar\0";
pub const LV2_TIME__beat: &[u8; 35usize] = b"http://lv2plug.in/ns/ext/time#beat\0";
pub const LV2_TIME__beatUnit: &[u8; 39usize] = b"http://lv2plug.in/ns/ext/time#beatUnit\0";
pub const LV2_TIME__beatsPerBar: &[u8; 42usize] = b"http://lv2plug.in/ns/ext/time#beatsPerBar\0";
pub const LV2_TIME__beatsPerMinute: &[u8; 45usize] =
    b"http://lv2plug.in/ns/ext/time#beatsPerMinute\0";
pub const LV2_TIME__frame: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/time#frame\0";
pub const LV2_TIME__framesPerSecond: &[u8; 46usize] =
    b"http://lv2plug.in/ns/ext/time#framesPerSecond\0";
pub const LV2_TIME__speed: &[u8; 36usize] = b"http://lv2plug.in/ns/ext/time#speed\0";
pub const LV2_UI_URI: &[u8; 35usize] = b"http://lv2plug.in/ns/extensions/ui\0";
pub const LV2_UI_PREFIX: &[u8; 36usize] = b"http://lv2plug.in/ns/extensions/ui#\0";
pub const LV2_UI__CocoaUI: &[u8; 43usize] = b"http://lv2plug.in/ns/extensions/ui#CocoaUI\0";
pub const LV2_UI__Gtk3UI: &[u8; 42usize] = b"http://lv2plug.in/ns/extensions/ui#Gtk3UI\0";
pub const LV2_UI__GtkUI: &[u8; 41usize] = b"http://lv2plug.in/ns/extensions/ui#GtkUI\0";
pub const LV2_UI__PortNotification: &[u8; 52usize] =
    b"http://lv2plug.in/ns/extensions/ui#PortNotification\0";
pub const LV2_UI__PortProtocol: &[u8; 48usize] =
    b"http://lv2plug.in/ns/extensions/ui#PortProtocol\0";
pub const LV2_UI__Qt4UI: &[u8; 41usize] = b"http://lv2plug.in/ns/extensions/ui#Qt4UI\0";
pub const LV2_UI__Qt5UI: &[u8; 41usize] = b"http://lv2plug.in/ns/extensions/ui#Qt5UI\0";
pub const LV2_UI__UI: &[u8; 38usize] = b"http://lv2plug.in/ns/extensions/ui#UI\0";
pub const LV2_UI__WindowsUI: &[u8; 45usize] = b"http://lv2plug.in/ns/extensions/ui#WindowsUI\0";
pub const LV2_UI__X11UI: &[u8; 41usize] = b"http://lv2plug.in/ns/extensions/ui#X11UI\0";
pub const LV2_UI__binary: &[u8; 42usize] = b"http://lv2plug.in/ns/extensions/ui#binary\0";
pub const LV2_UI__fixedSize: &[u8; 45usize] = b"http://lv2plug.in/ns/extensions/ui#fixedSize\0";
pub const LV2_UI__idleInterface: &[u8; 49usize] =
    b"http://lv2plug.in/ns/extensions/ui#idleInterface\0";
pub const LV2_UI__noUserResize: &[u8; 48usize] =
    b"http://lv2plug.in/ns/extensions/ui#noUserResize\0";
pub const LV2_UI__notifyType: &[u8; 46usize] = b"http://lv2plug.in/ns/extensions/ui#notifyType\0";
pub const LV2_UI__parent: &[u8; 42usize] = b"http://lv2plug.in/ns/extensions/ui#parent\0";
pub const LV2_UI__plugin: &[u8; 42usize] = b"http://lv2plug.in/ns/extensions/ui#plugin\0";
pub const LV2_UI__portIndex: &[u8; 45usize] = b"http://lv2plug.in/ns/extensions/ui#portIndex\0";
pub const LV2_UI__portMap: &[u8; 43usize] = b"http://lv2plug.in/ns/extensions/ui#portMap\0";
pub const LV2_UI__portNotification: &[u8; 52usize] =
    b"http://lv2plug.in/ns/extensions/ui#portNotification\0";
pub const LV2_UI__portSubscribe: &[u8; 49usize] =
    b"http://lv2plug.in/ns/extensions/ui#portSubscribe\0";
pub const LV2_UI__protocol: &[u8; 44usize] = b"http://lv2plug.in/ns/extensions/ui#protocol\0";
pub const LV2_UI__requestValue: &[u8; 48usize] =
    b"http://lv2plug.in/ns/extensions/ui#requestValue\0";
pub const LV2_UI__floatProtocol: &[u8; 49usize] =
    b"http://lv2plug.in/ns/extensions/ui#floatProtocol\0";
pub const LV2_UI__peakProtocol: &[u8; 48usize] =
    b"http://lv2plug.in/ns/extensions/ui#peakProtocol\0";
pub const LV2_UI__resize: &[u8; 42usize] = b"http://lv2plug.in/ns/extensions/ui#resize\0";
pub const LV2_UI__showInterface: &[u8; 49usize] =
    b"http://lv2plug.in/ns/extensions/ui#showInterface\0";
pub const LV2_UI__touch: &[u8; 41usize] = b"http://lv2plug.in/ns/extensions/ui#touch\0";
pub const LV2_UI__ui: &[u8; 38usize] = b"http://lv2plug.in/ns/extensions/ui#ui\0";
pub const LV2_UI__updateRate: &[u8; 46usize] = b"http://lv2plug.in/ns/extensions/ui#updateRate\0";
pub const LV2_UI__windowTitle: &[u8; 47usize] = b"http://lv2plug.in/ns/extensions/ui#windowTitle\0";
pub const LV2_UI__scaleFactor: &[u8; 47usize] = b"http://lv2plug.in/ns/extensions/ui#scaleFactor\0";
pub const LV2_UI__foregroundColor: &[u8; 51usize] =
    b"http://lv2plug.in/ns/extensions/ui#foregroundColor\0";
pub const LV2_UI__backgroundColor: &[u8; 51usize] =
    b"http://lv2plug.in/ns/extensions/ui#backgroundColor\0";
pub const LV2_UNITS_URI: &[u8; 38usize] = b"http://lv2plug.in/ns/extensions/units\0";
pub const LV2_UNITS_PREFIX: &[u8; 39usize] = b"http://lv2plug.in/ns/extensions/units#\0";
pub const LV2_UNITS__Conversion: &[u8; 49usize] =
    b"http://lv2plug.in/ns/extensions/units#Conversion\0";
pub const LV2_UNITS__Unit: &[u8; 43usize] = b"http://lv2plug.in/ns/extensions/units#Unit\0";
pub const LV2_UNITS__bar: &[u8; 42usize] = b"http://lv2plug.in/ns/extensions/units#bar\0";
pub const LV2_UNITS__beat: &[u8; 43usize] = b"http://lv2plug.in/ns/extensions/units#beat\0";
pub const LV2_UNITS__bpm: &[u8; 42usize] = b"http://lv2plug.in/ns/extensions/units#bpm\0";
pub const LV2_UNITS__cent: &[u8; 43usize] = b"http://lv2plug.in/ns/extensions/units#cent\0";
pub const LV2_UNITS__cm: &[u8; 41usize] = b"http://lv2plug.in/ns/extensions/units#cm\0";
pub const LV2_UNITS__coef: &[u8; 43usize] = b"http://lv2plug.in/ns/extensions/units#coef\0";
pub const LV2_UNITS__conversion: &[u8; 49usize] =
    b"http://lv2plug.in/ns/extensions/units#conversion\0";
pub const LV2_UNITS__db: &[u8; 41usize] = b"http://lv2plug.in/ns/extensions/units#db\0";
pub const LV2_UNITS__degree: &[u8; 45usize] = b"http://lv2plug.in/ns/extensions/units#degree\0";
pub const LV2_UNITS__frame: &[u8; 44usize] = b"http://lv2plug.in/ns/extensions/units#frame\0";
pub const LV2_UNITS__hz: &[u8; 41usize] = b"http://lv2plug.in/ns/extensions/units#hz\0";
pub const LV2_UNITS__inch: &[u8; 43usize] = b"http://lv2plug.in/ns/extensions/units#inch\0";
pub const LV2_UNITS__khz: &[u8; 42usize] = b"http://lv2plug.in/ns/extensions/units#khz\0";
pub const LV2_UNITS__km: &[u8; 41usize] = b"http://lv2plug.in/ns/extensions/units#km\0";
pub const LV2_UNITS__m: &[u8; 40usize] = b"http://lv2plug.in/ns/extensions/units#m\0";
pub const LV2_UNITS__mhz: &[u8; 42usize] = b"http://lv2plug.in/ns/extensions/units#mhz\0";
pub const LV2_UNITS__midiNote: &[u8; 47usize] = b"http://lv2plug.in/ns/extensions/units#midiNote\0";
pub const LV2_UNITS__mile: &[u8; 43usize] = b"http://lv2plug.in/ns/extensions/units#mile\0";
pub const LV2_UNITS__min: &[u8; 42usize] = b"http://lv2plug.in/ns/extensions/units#min\0";
pub const LV2_UNITS__mm: &[u8; 41usize] = b"http://lv2plug.in/ns/extensions/units#mm\0";
pub const LV2_UNITS__ms: &[u8; 41usize] = b"http://lv2plug.in/ns/extensions/units#ms\0";
pub const LV2_UNITS__name: &[u8; 43usize] = b"http://lv2plug.in/ns/extensions/units#name\0";
pub const LV2_UNITS__oct: &[u8; 42usize] = b"http://lv2plug.in/ns/extensions/units#oct\0";
pub const LV2_UNITS__pc: &[u8; 41usize] = b"http://lv2plug.in/ns/extensions/units#pc\0";
pub const LV2_UNITS__prefixConversion: &[u8; 55usize] =
    b"http://lv2plug.in/ns/extensions/units#prefixConversion\0";
pub const LV2_UNITS__render: &[u8; 45usize] = b"http://lv2plug.in/ns/extensions/units#render\0";
pub const LV2_UNITS__s: &[u8; 40usize] = b"http://lv2plug.in/ns/extensions/units#s\0";
pub const LV2_UNITS__semitone12TET: &[u8; 52usize] =
    b"http://lv2plug.in/ns/extensions/units#semitone12TET\0";
pub const LV2_UNITS__symbol: &[u8; 45usize] = b"http://lv2plug.in/ns/extensions/units#symbol\0";
pub const LV2_UNITS__unit: &[u8; 43usize] = b"http://lv2plug.in/ns/extensions/units#unit\0";
pub const LV2_URI_MAP_URI: &[u8; 33usize] = b"http://lv2plug.in/ns/ext/uri-map\0";
pub const LV2_URI_MAP_PREFIX: &[u8; 34usize] = b"http://lv2plug.in/ns/ext/uri-map#\0";
pub const LV2_WORKER_URI: &[u8; 32usize] = b"http://lv2plug.in/ns/ext/worker\0";
pub const LV2_WORKER_PREFIX: &[u8; 33usize] = b"http://lv2plug.in/ns/ext/worker#\0";
pub const LV2_WORKER__interface: &[u8; 42usize] = b"http://lv2plug.in/ns/ext/worker#interface\0";
pub const LV2_WORKER__schedule: &[u8; 41usize] = b"http://lv2plug.in/ns/ext/worker#schedule\0";
#[doc = " The header of an atom:Atom."]
#[repr(C, align(8))]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom {
    #[doc = "< Size in bytes, not including type and size."]
    pub size: u32,
    #[doc = "< Type of this atom (mapped URI)."]
    pub type_: u32,
}
#[doc = " An atom:Int or atom:Bool.  May be cast to LV2_Atom."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_Int {
    #[doc = "< Atom header."]
    pub atom: LV2_Atom,
    #[doc = "< Integer value."]
    pub body: i32,
}
#[doc = " An atom:Long.  May be cast to LV2_Atom."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_Long {
    #[doc = "< Atom header."]
    pub atom: LV2_Atom,
    #[doc = "< Integer value."]
    pub body: i64,
}
#[doc = " An atom:Float.  May be cast to LV2_Atom."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_Float {
    #[doc = "< Atom header."]
    pub atom: LV2_Atom,
    #[doc = "< Floating point value."]
    pub body: f32,
}
#[doc = " An atom:Double.  May be cast to LV2_Atom."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_Double {
    #[doc = "< Atom header."]
    pub atom: LV2_Atom,
    #[doc = "< Floating point value."]
    pub body: f64,
}
#[doc = " An atom:Int or atom:Bool.  May be cast to LV2_Atom."]
pub type LV2_Atom_Bool = LV2_Atom_Int;
#[doc = " An atom:URID.  May be cast to LV2_Atom."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_URID {
    #[doc = "< Atom header."]
    pub atom: LV2_Atom,
    #[doc = "< URID."]
    pub body: u32,
}
#[doc = " An atom:String.  May be cast to LV2_Atom."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_String {
    #[doc = "< Atom header."]
    pub atom: LV2_Atom,
}
#[doc = " The body of an atom:Literal."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_Literal_Body {
    #[doc = "< Datatype URID."]
    pub datatype: u32,
    #[doc = "< Language URID."]
    pub lang: u32,
}
#[doc = " An atom:Literal.  May be cast to LV2_Atom."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_Literal {
    #[doc = "< Atom header."]
    pub atom: LV2_Atom,
    #[doc = "< Body."]
    pub body: LV2_Atom_Literal_Body,
}
#[doc = " An atom:Tuple.  May be cast to LV2_Atom."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_Tuple {
    #[doc = "< Atom header."]
    pub atom: LV2_Atom,
}
#[doc = " The body of an atom:Vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_Vector_Body {
    #[doc = "< The size of each element in the vector."]
    pub child_size: u32,
    #[doc = "< The type of each element in the vector."]
    pub child_type: u32,
}
#[doc = " An atom:Vector.  May be cast to LV2_Atom."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_Vector {
    #[doc = "< Atom header."]
    pub atom: LV2_Atom,
    #[doc = "< Body."]
    pub body: LV2_Atom_Vector_Body,
}
#[doc = " The body of an atom:Property (typically in an atom:Object)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_Property_Body {
    #[doc = "< Key (predicate) (mapped URI)."]
    pub key: u32,
    #[doc = "< Context URID (may be, and generally is, 0)."]
    pub context: u32,
    #[doc = "< Value atom header."]
    pub value: LV2_Atom,
}
#[doc = " An atom:Property.  May be cast to LV2_Atom."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_Property {
    #[doc = "< Atom header."]
    pub atom: LV2_Atom,
    #[doc = "< Body."]
    pub body: LV2_Atom_Property_Body,
}
#[doc = " The body of an atom:Object. May be cast to LV2_Atom."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_Object_Body {
    #[doc = "< URID, or 0 for blank."]
    pub id: u32,
    #[doc = "< Type URID (same as rdf:type, for fast dispatch)."]
    pub otype: u32,
}
#[doc = " An atom:Object.  May be cast to LV2_Atom."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_Object {
    #[doc = "< Atom header."]
    pub atom: LV2_Atom,
    #[doc = "< Body."]
    pub body: LV2_Atom_Object_Body,
}
#[doc = " The header of an atom:Event.  Note this type is NOT an LV2_Atom."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LV2_Atom_Event {
    pub time: LV2_Atom_Event__bindgen_ty_1,
    #[doc = "< Event body atom header."]
    pub body: LV2_Atom,
}
#[doc = " Time stamp.  Which type is valid is determined by context."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union LV2_Atom_Event__bindgen_ty_1 {
    #[doc = "< Time in audio frames."]
    pub frames: i64,
    #[doc = "< Time in beats."]
    pub beats: f64,
}
#[doc = "The body of an atom:Sequence (a sequence of events)."]
#[doc = ""]
#[doc = "The unit field is either a URID that described an appropriate time stamp"]
#[doc = "type, or may be 0 where a default stamp type is known.  For"]
#[doc = "LV2_Descriptor::run(), the default stamp type is audio frames."]
#[doc = ""]
#[doc = "The contents of a sequence is a series of LV2_Atom_Event, each aligned"]
#[doc = "to 64-bits, for example:"]
#[doc = "<pre>"]
#[doc = "| Event 1 (size 6)                              | Event 2"]
#[doc = "|       |       |       |       |       |       |       |       |"]
#[doc = "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |"]
#[doc = "|FRAMES         |TYPE   |SIZE   |DATADATADATAPAD|FRAMES         |..."]
#[doc = "</pre>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_Sequence_Body {
    #[doc = "< URID of unit of event time stamps."]
    pub unit: u32,
    #[doc = "< Currently unused."]
    pub pad: u32,
}
#[doc = " An atom:Sequence."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_Sequence {
    #[doc = "< Atom header."]
    pub atom: LV2_Atom,
    #[doc = "< Body."]
    pub body: LV2_Atom_Sequence_Body,
}
pub type va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_Object_Query {
    pub key: u32,
    pub value: *mut *const LV2_Atom,
}
extern "C" {
    pub static LV2_ATOM_OBJECT_QUERY_END: LV2_Atom_Object_Query;
}
pub type LV2_URID_Map_Handle = *mut ::std::os::raw::c_void;
pub type LV2_URID_Unmap_Handle = *mut ::std::os::raw::c_void;
pub type LV2_URID = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_URID_Map {
    pub handle: LV2_URID_Map_Handle,
    pub map: ::std::option::Option<
        unsafe extern "C" fn(
            handle: LV2_URID_Map_Handle,
            uri: *const ::std::os::raw::c_char,
        ) -> LV2_URID,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_URID_Unmap {
    pub handle: LV2_URID_Unmap_Handle,
    pub unmap: ::std::option::Option<
        unsafe extern "C" fn(
            handle: LV2_URID_Unmap_Handle,
            urid: LV2_URID,
        ) -> *const ::std::os::raw::c_char,
    >,
}
#[doc = " Handle for LV2_Atom_Forge_Sink."]
pub type LV2_Atom_Forge_Sink_Handle = *mut ::std::os::raw::c_void;
#[doc = " A reference to a chunk of written output."]
pub type LV2_Atom_Forge_Ref = isize;
#[doc = " Sink function for writing output.  See lv2_atom_forge_set_sink()."]
pub type LV2_Atom_Forge_Sink = ::std::option::Option<
    unsafe extern "C" fn(
        handle: LV2_Atom_Forge_Sink_Handle,
        buf: *const ::std::os::raw::c_void,
        size: u32,
    ) -> LV2_Atom_Forge_Ref,
>;
#[doc = " Function for resolving a reference.  See lv2_atom_forge_set_sink()."]
pub type LV2_Atom_Forge_Deref_Func = ::std::option::Option<
    unsafe extern "C" fn(
        handle: LV2_Atom_Forge_Sink_Handle,
        ref_: LV2_Atom_Forge_Ref,
    ) -> *mut LV2_Atom,
>;
#[doc = " A stack frame used for keeping track of nested Atom containers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_Forge_Frame {
    pub parent: *mut LV2_Atom_Forge_Frame,
    pub ref_: LV2_Atom_Forge_Ref,
}
#[doc = " A \"forge\" for creating atoms by appending to a buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Atom_Forge {
    pub buf: *mut u8,
    pub offset: u32,
    pub size: u32,
    pub sink: LV2_Atom_Forge_Sink,
    pub deref: LV2_Atom_Forge_Deref_Func,
    pub handle: LV2_Atom_Forge_Sink_Handle,
    pub stack: *mut LV2_Atom_Forge_Frame,
    pub Blank: LV2_URID,
    pub Bool: LV2_URID,
    pub Chunk: LV2_URID,
    pub Double: LV2_URID,
    pub Float: LV2_URID,
    pub Int: LV2_URID,
    pub Long: LV2_URID,
    pub Literal: LV2_URID,
    pub Object: LV2_URID,
    pub Path: LV2_URID,
    pub Property: LV2_URID,
    pub Resource: LV2_URID,
    pub Sequence: LV2_URID,
    pub String: LV2_URID,
    pub Tuple: LV2_URID,
    pub URI: LV2_URID,
    pub URID: LV2_URID,
    pub Vector: LV2_URID,
}
#[doc = "Plugin Instance Handle."]
#[doc = ""]
#[doc = "This is a handle for one particular instance of a plugin.  It is valid to"]
#[doc = "compare to NULL (or 0 for C++) but otherwise the host MUST NOT attempt to"]
#[doc = "interpret it."]
pub type LV2_Handle = *mut ::std::os::raw::c_void;
#[doc = "Feature."]
#[doc = ""]
#[doc = "Features allow hosts to make additional functionality available to plugins"]
#[doc = "without requiring modification to the LV2 API.  Extensions may define new"]
#[doc = "features and specify the `URI` and `data` to be used if necessary."]
#[doc = "Some features, such as lv2:isLive, do not require the host to pass data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Feature {
    #[doc = "A globally unique, case-sensitive identifier (URI) for this feature."]
    #[doc = ""]
    #[doc = "This MUST be a valid URI string as defined by RFC 3986."]
    pub URI: *const ::std::os::raw::c_char,
    #[doc = "Pointer to arbitrary data."]
    #[doc = ""]
    #[doc = "The format of this data is defined by the extension which describes the"]
    #[doc = "feature with the given `URI`."]
    pub data: *mut ::std::os::raw::c_void,
}
#[doc = "Plugin Descriptor."]
#[doc = ""]
#[doc = "This structure provides the core functions necessary to instantiate and use"]
#[doc = "a plugin."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Descriptor {
    #[doc = "A globally unique, case-sensitive identifier for this plugin."]
    #[doc = ""]
    #[doc = "This MUST be a valid URI string as defined by RFC 3986.  All plugins with"]
    #[doc = "the same URI MUST be compatible to some degree, see"]
    #[doc = "http://lv2plug.in/ns/lv2core for details."]
    pub URI: *const ::std::os::raw::c_char,
    #[doc = "Instantiate the plugin."]
    #[doc = ""]
    #[doc = "Note that instance initialisation should generally occur in activate()"]
    #[doc = "rather than here. If a host calls instantiate(), it MUST call cleanup()"]
    #[doc = "at some point in the future."]
    #[doc = ""]
    #[doc = "@param descriptor Descriptor of the plugin to instantiate."]
    #[doc = ""]
    #[doc = "@param sample_rate Sample rate, in Hz, for the new plugin instance."]
    #[doc = ""]
    #[doc = "@param bundle_path Path to the LV2 bundle which contains this plugin"]
    #[doc = "binary. It MUST include the trailing directory separator so that simply"]
    #[doc = "appending a filename will yield the path to that file in the bundle."]
    #[doc = ""]
    #[doc = "@param features A NULL terminated array of LV2_Feature structs which"]
    #[doc = "represent the features the host supports. Plugins may refuse to"]
    #[doc = "instantiate if required features are not found here. However, hosts MUST"]
    #[doc = "NOT use this as a discovery mechanism: instead, use the RDF data to"]
    #[doc = "determine which features are required and do not attempt to instantiate"]
    #[doc = "unsupported plugins at all. This parameter MUST NOT be NULL, i.e. a host"]
    #[doc = "that supports no features MUST pass a single element array containing"]
    #[doc = "NULL."]
    #[doc = ""]
    #[doc = "@return A handle for the new plugin instance, or NULL if instantiation"]
    #[doc = "has failed."]
    pub instantiate: ::std::option::Option<
        unsafe extern "C" fn(
            descriptor: *const LV2_Descriptor,
            sample_rate: f64,
            bundle_path: *const ::std::os::raw::c_char,
            features: *const *const LV2_Feature,
        ) -> LV2_Handle,
    >,
    #[doc = "Connect a port on a plugin instance to a memory location."]
    #[doc = ""]
    #[doc = "Plugin writers should be aware that the host may elect to use the same"]
    #[doc = "buffer for more than one port and even use the same buffer for both"]
    #[doc = "input and output (see lv2:inPlaceBroken in lv2.ttl)."]
    #[doc = ""]
    #[doc = "If the plugin has the feature lv2:hardRTCapable then there are various"]
    #[doc = "things that the plugin MUST NOT do within the connect_port() function;"]
    #[doc = "see lv2core.ttl for details."]
    #[doc = ""]
    #[doc = "connect_port() MUST be called at least once for each port before run()"]
    #[doc = "is called, unless that port is lv2:connectionOptional. The plugin must"]
    #[doc = "pay careful attention to the block size passed to run() since the block"]
    #[doc = "allocated may only just be large enough to contain the data, and is not"]
    #[doc = "guaranteed to remain constant between run() calls."]
    #[doc = ""]
    #[doc = "connect_port() may be called more than once for a plugin instance to"]
    #[doc = "allow the host to change the buffers that the plugin is reading or"]
    #[doc = "writing. These calls may be made before or after activate() or"]
    #[doc = "deactivate() calls."]
    #[doc = ""]
    #[doc = "@param instance Plugin instance containing the port."]
    #[doc = ""]
    #[doc = "@param port Index of the port to connect. The host MUST NOT try to"]
    #[doc = "connect a port index that is not defined in the plugin's RDF data. If"]
    #[doc = "it does, the plugin's behaviour is undefined (a crash is likely)."]
    #[doc = ""]
    #[doc = "@param data_location Pointer to data of the type defined by the port"]
    #[doc = "type in the plugin's RDF data (for example, an array of float for an"]
    #[doc = "lv2:AudioPort). This pointer must be stored by the plugin instance and"]
    #[doc = "used to read/write data when run() is called. Data present at the time"]
    #[doc = "of the connect_port() call MUST NOT be considered meaningful."]
    pub connect_port: ::std::option::Option<
        unsafe extern "C" fn(
            instance: LV2_Handle,
            port: u32,
            data_location: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = "Initialise a plugin instance and activate it for use."]
    #[doc = ""]
    #[doc = "This is separated from instantiate() to aid real-time support and so"]
    #[doc = "that hosts can reinitialise a plugin instance by calling deactivate()"]
    #[doc = "and then activate(). In this case the plugin instance MUST reset all"]
    #[doc = "state information dependent on the history of the plugin instance except"]
    #[doc = "for any data locations provided by connect_port(). If there is nothing"]
    #[doc = "for activate() to do then this field may be NULL."]
    #[doc = ""]
    #[doc = "When present, hosts MUST call this function once before run() is called"]
    #[doc = "for the first time. This call SHOULD be made as close to the run() call"]
    #[doc = "as possible and indicates to real-time plugins that they are now live,"]
    #[doc = "however plugins MUST NOT rely on a prompt call to run() after"]
    #[doc = "activate()."]
    #[doc = ""]
    #[doc = "The host MUST NOT call activate() again until deactivate() has been"]
    #[doc = "called first. If a host calls activate(), it MUST call deactivate() at"]
    #[doc = "some point in the future. Note that connect_port() may be called before"]
    #[doc = "or after activate()."]
    pub activate: ::std::option::Option<unsafe extern "C" fn(instance: LV2_Handle)>,
    #[doc = "Run a plugin instance for a block."]
    #[doc = ""]
    #[doc = "Note that if an activate() function exists then it must be called before"]
    #[doc = "run(). If deactivate() is called for a plugin instance then run() may"]
    #[doc = "not be called until activate() has been called again."]
    #[doc = ""]
    #[doc = "If the plugin has the feature lv2:hardRTCapable then there are various"]
    #[doc = "things that the plugin MUST NOT do within the run() function (see"]
    #[doc = "lv2core.ttl for details)."]
    #[doc = ""]
    #[doc = "As a special case, when `sample_count` is 0, the plugin should update"]
    #[doc = "any output ports that represent a single instant in time (for example,"]
    #[doc = "control ports, but not audio ports). This is particularly useful for"]
    #[doc = "latent plugins, which should update their latency output port so hosts"]
    #[doc = "can pre-roll plugins to compute latency. Plugins MUST NOT crash when"]
    #[doc = "`sample_count` is 0."]
    #[doc = ""]
    #[doc = "@param instance Instance to be run."]
    #[doc = ""]
    #[doc = "@param sample_count The block size (in samples) for which the plugin"]
    #[doc = "instance must run."]
    pub run: ::std::option::Option<unsafe extern "C" fn(instance: LV2_Handle, sample_count: u32)>,
    #[doc = "Deactivate a plugin instance (counterpart to activate())."]
    #[doc = ""]
    #[doc = "Hosts MUST deactivate all activated instances after they have been run()"]
    #[doc = "for the last time. This call SHOULD be made as close to the last run()"]
    #[doc = "call as possible and indicates to real-time plugins that they are no"]
    #[doc = "longer live, however plugins MUST NOT rely on prompt deactivation. If"]
    #[doc = "there is nothing for deactivate() to do then this field may be NULL"]
    #[doc = ""]
    #[doc = "Deactivation is not similar to pausing since the plugin instance will be"]
    #[doc = "reinitialised by activate(). However, deactivate() itself MUST NOT fully"]
    #[doc = "reset plugin state. For example, the host may deactivate a plugin, then"]
    #[doc = "store its state (using some extension to do so)."]
    #[doc = ""]
    #[doc = "Hosts MUST NOT call deactivate() unless activate() was previously"]
    #[doc = "called. Note that connect_port() may be called before or after"]
    #[doc = "deactivate()."]
    pub deactivate: ::std::option::Option<unsafe extern "C" fn(instance: LV2_Handle)>,
    #[doc = "Clean up a plugin instance (counterpart to instantiate())."]
    #[doc = ""]
    #[doc = "Once an instance of a plugin has been finished with it must be deleted"]
    #[doc = "using this function. The instance handle passed ceases to be valid after"]
    #[doc = "this call."]
    #[doc = ""]
    #[doc = "If activate() was called for a plugin instance then a corresponding call"]
    #[doc = "to deactivate() MUST be made before cleanup() is called. Hosts MUST NOT"]
    #[doc = "call cleanup() unless instantiate() was previously called."]
    pub cleanup: ::std::option::Option<unsafe extern "C" fn(instance: LV2_Handle)>,
    #[doc = "Return additional plugin data defined by some extension."]
    #[doc = ""]
    #[doc = "A typical use of this facility is to return a struct containing function"]
    #[doc = "pointers to extend the LV2_Descriptor API."]
    #[doc = ""]
    #[doc = "The actual type and meaning of the returned object MUST be specified"]
    #[doc = "precisely by the extension. This function MUST return NULL for any"]
    #[doc = "unsupported URI. If a plugin does not support any extension data, this"]
    #[doc = "field may be NULL."]
    #[doc = ""]
    #[doc = "The host is never responsible for freeing the returned value."]
    pub extension_data: ::std::option::Option<
        unsafe extern "C" fn(uri: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_void,
    >,
}
#[doc = "Type of the lv2_descriptor() function in a library (old discovery API)."]
pub type LV2_Descriptor_Function =
    ::std::option::Option<unsafe extern "C" fn(index: u32) -> *const LV2_Descriptor>;
#[doc = "Handle for a library descriptor."]
pub type LV2_Lib_Handle = *mut ::std::os::raw::c_void;
#[doc = "Descriptor for a plugin library."]
#[doc = ""]
#[doc = "To access a plugin library, the host creates an LV2_Lib_Descriptor via the"]
#[doc = "lv2_lib_descriptor() function in the shared object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Lib_Descriptor {
    #[doc = "Opaque library data which must be passed as the first parameter to all"]
    #[doc = "the methods of this struct."]
    pub handle: LV2_Lib_Handle,
    #[doc = "The total size of this struct.  This allows for this struct to be"]
    #[doc = "expanded in the future if necessary.  This MUST be set by the library to"]
    #[doc = "sizeof(LV2_Lib_Descriptor).  The host MUST NOT access any fields of this"]
    #[doc = "struct beyond get_plugin() unless this field indicates they are present."]
    pub size: u32,
    #[doc = "Destroy this library descriptor and free all related resources."]
    pub cleanup: ::std::option::Option<unsafe extern "C" fn(handle: LV2_Lib_Handle)>,
    #[doc = "Plugin accessor."]
    #[doc = ""]
    #[doc = "Plugins are accessed by index using values from 0 upwards.  Out of range"]
    #[doc = "indices MUST result in this function returning NULL, so the host can"]
    #[doc = "enumerate plugins by increasing `index` until NULL is returned."]
    pub get_plugin: ::std::option::Option<
        unsafe extern "C" fn(handle: LV2_Lib_Handle, index: u32) -> *const LV2_Descriptor,
    >,
}
#[doc = "Type of the lv2_lib_descriptor() function in an LV2 library."]
pub type LV2_Lib_Descriptor_Function = ::std::option::Option<
    unsafe extern "C" fn(
        bundle_path: *const ::std::os::raw::c_char,
        features: *const *const LV2_Feature,
    ) -> *const LV2_Lib_Descriptor,
>;
#[doc = "The data field of the LV2_Feature for this extension."]
#[doc = ""]
#[doc = "To support this feature the host must pass an LV2_Feature struct to the"]
#[doc = "instantiate method with URI \"http://lv2plug.in/ns/ext/data-access\""]
#[doc = "and data pointed to an instance of this struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Extension_Data_Feature {
    #[doc = "A pointer to a method the UI can call to get data (of a type specified"]
    #[doc = "by some other extension) from the plugin."]
    #[doc = ""]
    #[doc = "This call never is never guaranteed to return anything, UIs should"]
    #[doc = "degrade gracefully if direct access to the plugin data is not possible"]
    #[doc = "(in which case this function will return NULL)."]
    #[doc = ""]
    #[doc = "This is for access to large data that can only possibly work if the UI"]
    #[doc = "and plugin are running in the same process.  For all other things, use"]
    #[doc = "the normal LV2 UI communication system."]
    pub data_access: ::std::option::Option<
        unsafe extern "C" fn(uri: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_void,
    >,
}
#[doc = "Dynamic manifest generator handle."]
#[doc = ""]
#[doc = "This handle indicates a particular status of a dynamic manifest generator."]
#[doc = "The host MUST NOT attempt to interpret it and, unlikely LV2_Handle, it is"]
#[doc = "NOT even valid to compare this to NULL. The dynamic manifest generator MAY"]
#[doc = "use it to reference internal data."]
pub type LV2_Dyn_Manifest_Handle = *mut ::std::os::raw::c_void;
pub const LV2_EVENT_PPQN: u32 = 3136573440;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Event {
    pub frames: u32,
    pub subframes: u32,
    pub type_: u16,
    pub size: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Event_Buffer {
    pub data: *mut u8,
    pub header_size: u16,
    pub stamp_type: u16,
    pub event_count: u32,
    pub capacity: u32,
    pub size: u32,
}
pub type LV2_Event_Callback_Data = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Event_Feature {
    pub callback_data: LV2_Event_Callback_Data,
    pub lv2_event_ref: ::std::option::Option<
        unsafe extern "C" fn(callback_data: LV2_Event_Callback_Data, event: *mut LV2_Event) -> u32,
    >,
    pub lv2_event_unref: ::std::option::Option<
        unsafe extern "C" fn(callback_data: LV2_Event_Callback_Data, event: *mut LV2_Event) -> u32,
    >,
}
#[doc = " An iterator over an LV2_Event_Buffer."]
#[doc = ""]
#[doc = " Multiple simultaneous read iterators over a single buffer is fine,"]
#[doc = " but changing the buffer invalidates all iterators."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Event_Iterator {
    pub buf: *mut LV2_Event_Buffer,
    pub offset: u32,
}
#[doc = "Opaque data to host data for LV2_Log_Log."]
pub type LV2_Log_Handle = *mut ::std::os::raw::c_void;
#[doc = "Log feature (LV2_LOG__log)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Log_Log {
    #[doc = "Opaque pointer to host data."]
    #[doc = ""]
    #[doc = "This MUST be passed to methods in this struct whenever they are called."]
    #[doc = "Otherwise, it must not be interpreted in any way."]
    pub handle: LV2_Log_Handle,
    #[doc = "Log a message, passing format parameters directly."]
    #[doc = ""]
    #[doc = "The API of this function matches that of the standard C printf function,"]
    #[doc = "except for the addition of the first two parameters.  This function may"]
    #[doc = "be called from any non-realtime context, or from any context if `type`"]
    #[doc = "is @ref LV2_LOG__Trace."]
    pub printf: ::std::option::Option<
        unsafe extern "C" fn(
            handle: LV2_Log_Handle,
            type_: LV2_URID,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "Log a message, passing format parameters in a va_list."]
    #[doc = ""]
    #[doc = "The API of this function matches that of the standard C vprintf"]
    #[doc = "function, except for the addition of the first two parameters.  This"]
    #[doc = "function may be called from any non-realtime context, or from any"]
    #[doc = "context if `type` is @ref LV2_LOG__Trace."]
    pub vprintf: ::std::option::Option<
        unsafe extern "C" fn(
            handle: LV2_Log_Handle,
            type_: LV2_URID,
            fmt: *const ::std::os::raw::c_char,
            ap: va_list,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = "Logger convenience API state."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Log_Logger {
    pub log: *mut LV2_Log_Log,
    pub Error: LV2_URID,
    pub Note: LV2_URID,
    pub Trace: LV2_URID,
    pub Warning: LV2_URID,
}
#[doc = "< Invalid Message"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_INVALID: LV2_Midi_Message_Type = 0;
#[doc = "< Note Off"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_NOTE_OFF: LV2_Midi_Message_Type = 128;
#[doc = "< Note On"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_NOTE_ON: LV2_Midi_Message_Type = 144;
#[doc = "< Note Pressure"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_NOTE_PRESSURE: LV2_Midi_Message_Type = 160;
#[doc = "< Controller"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_CONTROLLER: LV2_Midi_Message_Type = 176;
#[doc = "< Program Change"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_PGM_CHANGE: LV2_Midi_Message_Type = 192;
#[doc = "< Channel Pressure"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_CHANNEL_PRESSURE: LV2_Midi_Message_Type = 208;
#[doc = "< Pitch Bender"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_BENDER: LV2_Midi_Message_Type = 224;
#[doc = "< System Exclusive Begin"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_SYSTEM_EXCLUSIVE: LV2_Midi_Message_Type = 240;
#[doc = "< MTC Quarter Frame"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_MTC_QUARTER: LV2_Midi_Message_Type = 241;
#[doc = "< Song Position"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_SONG_POS: LV2_Midi_Message_Type = 242;
#[doc = "< Song Select"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_SONG_SELECT: LV2_Midi_Message_Type = 243;
#[doc = "< Tune Request"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_TUNE_REQUEST: LV2_Midi_Message_Type = 246;
#[doc = "< Clock"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_CLOCK: LV2_Midi_Message_Type = 248;
#[doc = "< Start"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_START: LV2_Midi_Message_Type = 250;
#[doc = "< Continue"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_CONTINUE: LV2_Midi_Message_Type = 251;
#[doc = "< Stop"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_STOP: LV2_Midi_Message_Type = 252;
#[doc = "< Active Sensing"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_ACTIVE_SENSE: LV2_Midi_Message_Type = 254;
#[doc = "< Reset"]
pub const LV2_Midi_Message_Type_LV2_MIDI_MSG_RESET: LV2_Midi_Message_Type = 255;
#[doc = "MIDI Message Type."]
#[doc = ""]
#[doc = "This includes both voice messages (which have a channel) and system messages"]
#[doc = "(which do not), as well as a sentinel value for invalid messages.  To get"]
#[doc = "the type of a message suitable for use in a switch statement, use"]
#[doc = "lv2_midi_get_type() on the status byte."]
pub type LV2_Midi_Message_Type = ::std::os::raw::c_uint;
#[doc = "< Bank Selection"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_MSB_BANK: LV2_Midi_Controller = 0;
#[doc = "< Modulation"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_MSB_MODWHEEL: LV2_Midi_Controller = 1;
#[doc = "< Breath"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_MSB_BREATH: LV2_Midi_Controller = 2;
#[doc = "< Foot"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_MSB_FOOT: LV2_Midi_Controller = 4;
#[doc = "< Portamento Time"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_MSB_PORTAMENTO_TIME: LV2_Midi_Controller = 5;
#[doc = "< Data Entry"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_MSB_DATA_ENTRY: LV2_Midi_Controller = 6;
#[doc = "< Main Volume"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_MSB_MAIN_VOLUME: LV2_Midi_Controller = 7;
#[doc = "< Balance"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_MSB_BALANCE: LV2_Midi_Controller = 8;
#[doc = "< Panpot"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_MSB_PAN: LV2_Midi_Controller = 10;
#[doc = "< Expression"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_MSB_EXPRESSION: LV2_Midi_Controller = 11;
#[doc = "< Effect1"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_MSB_EFFECT1: LV2_Midi_Controller = 12;
#[doc = "< Effect2"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_MSB_EFFECT2: LV2_Midi_Controller = 13;
#[doc = "< General Purpose 1"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_MSB_GENERAL_PURPOSE1: LV2_Midi_Controller = 16;
#[doc = "< General Purpose 2"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_MSB_GENERAL_PURPOSE2: LV2_Midi_Controller = 17;
#[doc = "< General Purpose 3"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_MSB_GENERAL_PURPOSE3: LV2_Midi_Controller = 18;
#[doc = "< General Purpose 4"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_MSB_GENERAL_PURPOSE4: LV2_Midi_Controller = 19;
#[doc = "< Bank Selection"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_LSB_BANK: LV2_Midi_Controller = 32;
#[doc = "< Modulation"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_LSB_MODWHEEL: LV2_Midi_Controller = 33;
#[doc = "< Breath"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_LSB_BREATH: LV2_Midi_Controller = 34;
#[doc = "< Foot"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_LSB_FOOT: LV2_Midi_Controller = 36;
#[doc = "< Portamento Time"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_LSB_PORTAMENTO_TIME: LV2_Midi_Controller = 37;
#[doc = "< Data Entry"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_LSB_DATA_ENTRY: LV2_Midi_Controller = 38;
#[doc = "< Main Volume"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_LSB_MAIN_VOLUME: LV2_Midi_Controller = 39;
#[doc = "< Balance"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_LSB_BALANCE: LV2_Midi_Controller = 40;
#[doc = "< Panpot"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_LSB_PAN: LV2_Midi_Controller = 42;
#[doc = "< Expression"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_LSB_EXPRESSION: LV2_Midi_Controller = 43;
#[doc = "< Effect1"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_LSB_EFFECT1: LV2_Midi_Controller = 44;
#[doc = "< Effect2"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_LSB_EFFECT2: LV2_Midi_Controller = 45;
#[doc = "< General Purpose 1"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_LSB_GENERAL_PURPOSE1: LV2_Midi_Controller = 48;
#[doc = "< General Purpose 2"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_LSB_GENERAL_PURPOSE2: LV2_Midi_Controller = 49;
#[doc = "< General Purpose 3"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_LSB_GENERAL_PURPOSE3: LV2_Midi_Controller = 50;
#[doc = "< General Purpose 4"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_LSB_GENERAL_PURPOSE4: LV2_Midi_Controller = 51;
#[doc = "< Sustain Pedal"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_SUSTAIN: LV2_Midi_Controller = 64;
#[doc = "< Portamento"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_PORTAMENTO: LV2_Midi_Controller = 65;
#[doc = "< Sostenuto"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_SOSTENUTO: LV2_Midi_Controller = 66;
#[doc = "< Soft Pedal"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_SOFT_PEDAL: LV2_Midi_Controller = 67;
#[doc = "< Legato Foot Switch"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_LEGATO_FOOTSWITCH: LV2_Midi_Controller = 68;
#[doc = "< Hold2"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_HOLD2: LV2_Midi_Controller = 69;
#[doc = "< SC1 Sound Variation"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_SC1_SOUND_VARIATION: LV2_Midi_Controller = 70;
#[doc = "< SC2 Timbre"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_SC2_TIMBRE: LV2_Midi_Controller = 71;
#[doc = "< SC3 Release Time"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_SC3_RELEASE_TIME: LV2_Midi_Controller = 72;
#[doc = "< SC4 Attack Time"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_SC4_ATTACK_TIME: LV2_Midi_Controller = 73;
#[doc = "< SC5 Brightness"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_SC5_BRIGHTNESS: LV2_Midi_Controller = 74;
#[doc = "< SC6"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_SC6: LV2_Midi_Controller = 75;
#[doc = "< SC7"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_SC7: LV2_Midi_Controller = 76;
#[doc = "< SC8"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_SC8: LV2_Midi_Controller = 77;
#[doc = "< SC9"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_SC9: LV2_Midi_Controller = 78;
#[doc = "< SC10"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_SC10: LV2_Midi_Controller = 79;
#[doc = "< General Purpose 5"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_GENERAL_PURPOSE5: LV2_Midi_Controller = 80;
#[doc = "< General Purpose 6"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_GENERAL_PURPOSE6: LV2_Midi_Controller = 81;
#[doc = "< General Purpose 7"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_GENERAL_PURPOSE7: LV2_Midi_Controller = 82;
#[doc = "< General Purpose 8"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_GENERAL_PURPOSE8: LV2_Midi_Controller = 83;
#[doc = "< Portamento Control"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_PORTAMENTO_CONTROL: LV2_Midi_Controller = 84;
#[doc = "< E1 Reverb Depth"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_E1_REVERB_DEPTH: LV2_Midi_Controller = 91;
#[doc = "< E2 Tremolo Depth"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_E2_TREMOLO_DEPTH: LV2_Midi_Controller = 92;
#[doc = "< E3 Chorus Depth"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_E3_CHORUS_DEPTH: LV2_Midi_Controller = 93;
#[doc = "< E4 Detune Depth"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_E4_DETUNE_DEPTH: LV2_Midi_Controller = 94;
#[doc = "< E5 Phaser Depth"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_E5_PHASER_DEPTH: LV2_Midi_Controller = 95;
#[doc = "< Data Increment"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_DATA_INCREMENT: LV2_Midi_Controller = 96;
#[doc = "< Data Decrement"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_DATA_DECREMENT: LV2_Midi_Controller = 97;
#[doc = "< Non-registered Parameter Number"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_NRPN_LSB: LV2_Midi_Controller = 98;
#[doc = "< Non-registered Parameter Number"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_NRPN_MSB: LV2_Midi_Controller = 99;
#[doc = "< Registered Parameter Number"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_RPN_LSB: LV2_Midi_Controller = 100;
#[doc = "< Registered Parameter Number"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_RPN_MSB: LV2_Midi_Controller = 101;
#[doc = "< All Sounds Off"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_ALL_SOUNDS_OFF: LV2_Midi_Controller = 120;
#[doc = "< Reset Controllers"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_RESET_CONTROLLERS: LV2_Midi_Controller = 121;
#[doc = "< Local Control Switch"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_LOCAL_CONTROL_SWITCH: LV2_Midi_Controller = 122;
#[doc = "< All Notes Off"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_ALL_NOTES_OFF: LV2_Midi_Controller = 123;
#[doc = "< Omni Off"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_OMNI_OFF: LV2_Midi_Controller = 124;
#[doc = "< Omni On"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_OMNI_ON: LV2_Midi_Controller = 125;
#[doc = "< Mono1"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_MONO1: LV2_Midi_Controller = 126;
#[doc = "< Mono2"]
pub const LV2_Midi_Controller_LV2_MIDI_CTL_MONO2: LV2_Midi_Controller = 127;
#[doc = "Standard MIDI Controller Numbers."]
pub type LV2_Midi_Controller = ::std::os::raw::c_uint;
#[doc = "This option applies to the instance itself.  The subject must be"]
#[doc = "ignored."]
pub const LV2_Options_Context_LV2_OPTIONS_INSTANCE: LV2_Options_Context = 0;
#[doc = "This option applies to some named resource.  The subject is a URI mapped"]
#[doc = "to an integer (a LV2_URID, like the key)"]
pub const LV2_Options_Context_LV2_OPTIONS_RESOURCE: LV2_Options_Context = 1;
#[doc = "This option applies to some blank node.  The subject is a blank node"]
#[doc = "identifier, which is valid only within the current local scope."]
pub const LV2_Options_Context_LV2_OPTIONS_BLANK: LV2_Options_Context = 2;
#[doc = "This option applies to a port on the instance.  The subject is the"]
#[doc = "port's index."]
pub const LV2_Options_Context_LV2_OPTIONS_PORT: LV2_Options_Context = 3;
#[doc = "The context of an Option, which defines the subject it applies to."]
pub type LV2_Options_Context = ::std::os::raw::c_uint;
#[doc = "An option."]
#[doc = ""]
#[doc = "This is a property with a subject, also known as a triple or statement."]
#[doc = ""]
#[doc = "This struct is useful anywhere a statement needs to be passed where no"]
#[doc = "memory ownership issues are present (since the value is a const pointer)."]
#[doc = ""]
#[doc = "Options can be passed to an instance via the feature LV2_OPTIONS__options"]
#[doc = "with data pointed to an array of options terminated by a zeroed option, or"]
#[doc = "accessed/manipulated using LV2_Options_Interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Options_Option {
    #[doc = "< Context (type of subject)."]
    pub context: LV2_Options_Context,
    #[doc = "< Subject."]
    pub subject: u32,
    #[doc = "< Key (property)."]
    pub key: LV2_URID,
    #[doc = "< Size of value in bytes."]
    pub size: u32,
    #[doc = "< Type of value (datatype)."]
    pub type_: LV2_URID,
    #[doc = "< Pointer to value (object)."]
    pub value: *const ::std::os::raw::c_void,
}
#[doc = "< Completed successfully."]
pub const LV2_Options_Status_LV2_OPTIONS_SUCCESS: LV2_Options_Status = 0;
#[doc = "< Unknown error."]
pub const LV2_Options_Status_LV2_OPTIONS_ERR_UNKNOWN: LV2_Options_Status = 1;
#[doc = "< Invalid/unsupported subject."]
pub const LV2_Options_Status_LV2_OPTIONS_ERR_BAD_SUBJECT: LV2_Options_Status = 2;
#[doc = "< Invalid/unsupported key."]
pub const LV2_Options_Status_LV2_OPTIONS_ERR_BAD_KEY: LV2_Options_Status = 4;
#[doc = "< Invalid/unsupported value."]
pub const LV2_Options_Status_LV2_OPTIONS_ERR_BAD_VALUE: LV2_Options_Status = 8;
#[doc = " A status code for option functions."]
pub type LV2_Options_Status = ::std::os::raw::c_uint;
#[doc = "Interface for dynamically setting options (LV2_OPTIONS__interface)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Options_Interface {
    #[doc = "Get the given options."]
    #[doc = ""]
    #[doc = "Each element of the passed options array MUST have type, subject, and"]
    #[doc = "key set.  All other fields (size, type, value) MUST be initialised to"]
    #[doc = "zero, and are set to the option value if such an option is found."]
    #[doc = ""]
    #[doc = "This function is in the \"instantiation\" LV2 threading class, so no other"]
    #[doc = "instance functions may be called concurrently."]
    #[doc = ""]
    #[doc = "@return Bitwise OR of LV2_Options_Status values."]
    pub get: ::std::option::Option<
        unsafe extern "C" fn(instance: LV2_Handle, options: *mut LV2_Options_Option) -> u32,
    >,
    #[doc = "Set the given options."]
    #[doc = ""]
    #[doc = "This function is in the \"instantiation\" LV2 threading class, so no other"]
    #[doc = "instance functions may be called concurrently."]
    #[doc = ""]
    #[doc = "@return Bitwise OR of LV2_Options_Status values."]
    pub set: ::std::option::Option<
        unsafe extern "C" fn(instance: LV2_Handle, options: *const LV2_Options_Option) -> u32,
    >,
}
#[doc = "< Completed successfully."]
pub const LV2_Resize_Port_Status_LV2_RESIZE_PORT_SUCCESS: LV2_Resize_Port_Status = 0;
#[doc = "< Unknown error."]
pub const LV2_Resize_Port_Status_LV2_RESIZE_PORT_ERR_UNKNOWN: LV2_Resize_Port_Status = 1;
#[doc = "< Insufficient space."]
pub const LV2_Resize_Port_Status_LV2_RESIZE_PORT_ERR_NO_SPACE: LV2_Resize_Port_Status = 2;
#[doc = " A status code for state functions."]
pub type LV2_Resize_Port_Status = ::std::os::raw::c_uint;
#[doc = " Opaque data for resize method."]
pub type LV2_Resize_Port_Feature_Data = *mut ::std::os::raw::c_void;
#[doc = " Host feature to allow plugins to resize their port buffers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Resize_Port_Resize {
    #[doc = " Opaque data for resize method."]
    pub data: LV2_Resize_Port_Feature_Data,
    #[doc = "Resize a port buffer to at least `size` bytes."]
    #[doc = ""]
    #[doc = "This function MAY return an error, in which case the port buffer was not"]
    #[doc = "resized and the port is still connected to the same location.  Plugins"]
    #[doc = "MUST gracefully handle this situation."]
    #[doc = ""]
    #[doc = "This function is in the audio threading class."]
    #[doc = ""]
    #[doc = "The host MUST preserve the contents of the port buffer when resizing."]
    #[doc = ""]
    #[doc = "Plugins MAY resize a port many times in a single run callback.  Hosts"]
    #[doc = "SHOULD make this as inexpensive as possible."]
    pub resize: ::std::option::Option<
        unsafe extern "C" fn(
            data: LV2_Resize_Port_Feature_Data,
            index: u32,
            size: usize,
        ) -> LV2_Resize_Port_Status,
    >,
}
pub type LV2_State_Handle = *mut ::std::os::raw::c_void;
pub type LV2_State_Free_Path_Handle = *mut ::std::os::raw::c_void;
pub type LV2_State_Map_Path_Handle = *mut ::std::os::raw::c_void;
pub type LV2_State_Make_Path_Handle = *mut ::std::os::raw::c_void;
impl LV2_State_Flags {
    #[doc = "Plain Old Data."]
    #[doc = ""]
    #[doc = "Values with this flag contain no pointers or references to other areas"]
    #[doc = "of memory.  It is safe to copy POD values with a simple memcpy and store"]
    #[doc = "them for the duration of the process.  A POD value is not necessarily"]
    #[doc = "safe to transmit between processes or machines (for example, filenames"]
    #[doc = "are POD), see LV2_STATE_IS_PORTABLE for details."]
    #[doc = ""]
    #[doc = "Implementations MUST NOT attempt to copy or serialise a non-POD value if"]
    #[doc = "they do not understand its type (and thus know how to correctly do so)."]
    pub const LV2_STATE_IS_POD: LV2_State_Flags = LV2_State_Flags(1);
}
impl LV2_State_Flags {
    #[doc = "Portable (architecture independent) data."]
    #[doc = ""]
    #[doc = "Values with this flag are in a format that is usable on any"]
    #[doc = "architecture.  A portable value saved on one machine can be restored on"]
    #[doc = "another machine regardless of architecture.  The format of portable"]
    #[doc = "values MUST NOT depend on architecture-specific properties like"]
    #[doc = "endianness or alignment.  Portable values MUST NOT contain filenames."]
    pub const LV2_STATE_IS_PORTABLE: LV2_State_Flags = LV2_State_Flags(2);
}
impl LV2_State_Flags {
    #[doc = "Native data."]
    #[doc = ""]
    #[doc = "This flag is used by the host to indicate that the saved data is only"]
    #[doc = "going to be used locally in the currently running process (for things"]
    #[doc = "like instance duplication or snapshots), so the plugin should use the"]
    #[doc = "most efficient representation possible and not worry about serialisation"]
    #[doc = "and portability."]
    pub const LV2_STATE_IS_NATIVE: LV2_State_Flags = LV2_State_Flags(4);
}
impl ::std::ops::BitOr<LV2_State_Flags> for LV2_State_Flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        LV2_State_Flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for LV2_State_Flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: LV2_State_Flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<LV2_State_Flags> for LV2_State_Flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        LV2_State_Flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for LV2_State_Flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: LV2_State_Flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = "Flags describing value characteristics."]
#[doc = ""]
#[doc = "These flags are used along with the value's type URI to determine how to"]
#[doc = "(de-)serialise the value data, or whether it is even possible to do so."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LV2_State_Flags(pub ::std::os::raw::c_uint);
#[doc = "< Completed successfully."]
pub const LV2_State_Status_LV2_STATE_SUCCESS: LV2_State_Status = 0;
#[doc = "< Unknown error."]
pub const LV2_State_Status_LV2_STATE_ERR_UNKNOWN: LV2_State_Status = 1;
#[doc = "< Failed due to unsupported type."]
pub const LV2_State_Status_LV2_STATE_ERR_BAD_TYPE: LV2_State_Status = 2;
#[doc = "< Failed due to unsupported flags."]
pub const LV2_State_Status_LV2_STATE_ERR_BAD_FLAGS: LV2_State_Status = 3;
#[doc = "< Failed due to missing features."]
pub const LV2_State_Status_LV2_STATE_ERR_NO_FEATURE: LV2_State_Status = 4;
#[doc = "< Failed due to missing property."]
pub const LV2_State_Status_LV2_STATE_ERR_NO_PROPERTY: LV2_State_Status = 5;
#[doc = "< Failed due to insufficient space."]
pub const LV2_State_Status_LV2_STATE_ERR_NO_SPACE: LV2_State_Status = 6;
#[doc = " A status code for state functions."]
pub type LV2_State_Status = ::std::os::raw::c_uint;
#[doc = "A host-provided function to store a property."]
#[doc = "@param handle Must be the handle passed to LV2_State_Interface.save()."]
#[doc = "@param key The key to store `value` under (URID)."]
#[doc = "@param value Pointer to the value to be stored."]
#[doc = "@param size The size of `value` in bytes."]
#[doc = "@param type The type of `value` (URID)."]
#[doc = "@param flags LV2_State_Flags for `value`."]
#[doc = "@return 0 on success, otherwise a non-zero error code."]
#[doc = ""]
#[doc = "The host passes a callback of this type to LV2_State_Interface.save(). This"]
#[doc = "callback is called repeatedly by the plugin to store all the properties that"]
#[doc = "describe its current state."]
#[doc = ""]
#[doc = "DO NOT INVENT NONSENSE URI SCHEMES FOR THE KEY.  Best is to use keys from"]
#[doc = "existing vocabularies.  If nothing appropriate is available, use http URIs"]
#[doc = "that point to somewhere you can host documents so documentation can be made"]
#[doc = "resolvable (typically a child of the plugin or project URI).  If this is not"]
#[doc = "possible, invent a URN scheme, e.g. urn:myproj:whatever.  The plugin MUST"]
#[doc = "NOT pass an invalid URI key."]
#[doc = ""]
#[doc = "The host MAY fail to store a property for whatever reason, but SHOULD"]
#[doc = "store any property that is LV2_STATE_IS_POD and LV2_STATE_IS_PORTABLE."]
#[doc = "Implementations SHOULD use the types from the LV2 Atom extension"]
#[doc = "(http://lv2plug.in/ns/ext/atom) wherever possible.  The plugin SHOULD"]
#[doc = "attempt to fall-back and avoid the error if possible."]
#[doc = ""]
#[doc = "Note that `size` MUST be > 0, and `value` MUST point to a valid region of"]
#[doc = "memory `size` bytes long (this is required to make restore unambiguous)."]
#[doc = ""]
#[doc = "The plugin MUST NOT attempt to use this function outside of the"]
#[doc = "LV2_State_Interface.restore() context."]
pub type LV2_State_Store_Function = ::std::option::Option<
    unsafe extern "C" fn(
        handle: LV2_State_Handle,
        key: u32,
        value: *const ::std::os::raw::c_void,
        size: usize,
        type_: u32,
        flags: u32,
    ) -> LV2_State_Status,
>;
#[doc = "A host-provided function to retrieve a property."]
#[doc = "@param handle Must be the handle passed to LV2_State_Interface.restore()."]
#[doc = "@param key The key of the property to retrieve (URID)."]
#[doc = "@param size (Output) If non-NULL, set to the size of the restored value."]
#[doc = "@param type (Output) If non-NULL, set to the type of the restored value."]
#[doc = "@param flags (Output) If non-NULL, set to the flags for the restored value."]
#[doc = "@return A pointer to the restored value (object), or NULL if no value"]
#[doc = "has been stored under `key`."]
#[doc = ""]
#[doc = "A callback of this type is passed by the host to"]
#[doc = "LV2_State_Interface.restore().  This callback is called repeatedly by the"]
#[doc = "plugin to retrieve any properties it requires to restore its state."]
#[doc = ""]
#[doc = "The returned value MUST remain valid until LV2_State_Interface.restore()"]
#[doc = "returns.  The plugin MUST NOT attempt to use this function, or any value"]
#[doc = "returned from it, outside of the LV2_State_Interface.restore() context."]
pub type LV2_State_Retrieve_Function = ::std::option::Option<
    unsafe extern "C" fn(
        handle: LV2_State_Handle,
        key: u32,
        size: *mut usize,
        type_: *mut u32,
        flags: *mut u32,
    ) -> *const ::std::os::raw::c_void,
>;
#[doc = "LV2 Plugin State Interface."]
#[doc = ""]
#[doc = "When the plugin's extension_data is called with argument"]
#[doc = "LV2_STATE__interface, the plugin MUST return an LV2_State_Interface"]
#[doc = "structure, which remains valid for the lifetime of the plugin."]
#[doc = ""]
#[doc = "The host can use the contained function pointers to save and restore the"]
#[doc = "state of a plugin instance at any time, provided the threading restrictions"]
#[doc = "of the functions are met."]
#[doc = ""]
#[doc = "Stored data is only guaranteed to be compatible between instances of plugins"]
#[doc = "with the same URI (i.e. if a change to a plugin would cause a fatal error"]
#[doc = "when restoring state saved by a previous version of that plugin, the plugin"]
#[doc = "URI MUST change just as it must when ports change incompatibly).  Plugin"]
#[doc = "authors should consider this possibility, and always store sensible data"]
#[doc = "with meaningful types to avoid such problems in the future."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_State_Interface {
    #[doc = "Save plugin state using a host-provided `store` callback."]
    #[doc = ""]
    #[doc = "@param instance The instance handle of the plugin."]
    #[doc = "@param store The host-provided store callback."]
    #[doc = "@param handle An opaque pointer to host data which MUST be passed as the"]
    #[doc = "handle parameter to `store` if it is called."]
    #[doc = "@param flags Flags describing desired properties of this save.  These"]
    #[doc = "flags may be used to determine the most appropriate values to store."]
    #[doc = "@param features Extensible parameter for passing any additional"]
    #[doc = "features to be used for this save."]
    #[doc = ""]
    #[doc = "The plugin is expected to store everything necessary to completely"]
    #[doc = "restore its state later.  Plugins SHOULD store simple POD data whenever"]
    #[doc = "possible, and consider the possibility of state being restored much"]
    #[doc = "later on a different machine."]
    #[doc = ""]
    #[doc = "The `handle` pointer and `store` function MUST NOT be used"]
    #[doc = "beyond the scope of save()."]
    #[doc = ""]
    #[doc = "This function has its own special threading class: it may not be called"]
    #[doc = "concurrently with any \"Instantiation\" function, but it may be called"]
    #[doc = "concurrently with functions in any other class, unless the definition of"]
    #[doc = "that class prohibits it (for example, it may not be called concurrently"]
    #[doc = "with a \"Discovery\" function, but it may be called concurrently with an"]
    #[doc = "\"Audio\" function.  The plugin is responsible for any locking or"]
    #[doc = "lock-free techniques necessary to make this possible."]
    #[doc = ""]
    #[doc = "Note that in the simple case where state is only modified by restore(),"]
    #[doc = "there are no synchronization issues since save() is never called"]
    #[doc = "concurrently with restore() (though run() may read it during a save)."]
    #[doc = ""]
    #[doc = "Plugins that dynamically modify state while running, however, must take"]
    #[doc = "care to do so in such a way that a concurrent call to save() will save a"]
    #[doc = "consistent representation of plugin state for a single instant in time."]
    pub save: ::std::option::Option<
        unsafe extern "C" fn(
            instance: LV2_Handle,
            store: LV2_State_Store_Function,
            handle: LV2_State_Handle,
            flags: u32,
            features: *const *const LV2_Feature,
        ) -> LV2_State_Status,
    >,
    #[doc = "Restore plugin state using a host-provided `retrieve` callback."]
    #[doc = ""]
    #[doc = "@param instance The instance handle of the plugin."]
    #[doc = "@param retrieve The host-provided retrieve callback."]
    #[doc = "@param handle An opaque pointer to host data which MUST be passed as the"]
    #[doc = "handle parameter to `retrieve` if it is called."]
    #[doc = "@param flags Currently unused."]
    #[doc = "@param features Extensible parameter for passing any additional"]
    #[doc = "features to be used for this restore."]
    #[doc = ""]
    #[doc = "The plugin MAY assume a restored value was set by a previous call to"]
    #[doc = "LV2_State_Interface.save() by a plugin with the same URI."]
    #[doc = ""]
    #[doc = "The plugin MUST gracefully fall back to a default value when a value can"]
    #[doc = "not be retrieved.  This allows the host to reset the plugin state with"]
    #[doc = "an empty map."]
    #[doc = ""]
    #[doc = "The `handle` pointer and `store` function MUST NOT be used"]
    #[doc = "beyond the scope of restore()."]
    #[doc = ""]
    #[doc = "This function is in the \"Instantiation\" threading class as defined by"]
    #[doc = "LV2. This means it MUST NOT be called concurrently with any other"]
    #[doc = "function on the same plugin instance."]
    pub restore: ::std::option::Option<
        unsafe extern "C" fn(
            instance: LV2_Handle,
            retrieve: LV2_State_Retrieve_Function,
            handle: LV2_State_Handle,
            flags: u32,
            features: *const *const LV2_Feature,
        ) -> LV2_State_Status,
    >,
}
#[doc = "Feature data for state:mapPath (@ref LV2_STATE__mapPath)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_State_Map_Path {
    #[doc = "Opaque host data."]
    pub handle: LV2_State_Map_Path_Handle,
    #[doc = "Map an absolute path to an abstract path for use in plugin state."]
    #[doc = "@param handle MUST be the `handle` member of this struct."]
    #[doc = "@param absolute_path The absolute path of a file."]
    #[doc = "@return An abstract path suitable for use in plugin state."]
    #[doc = ""]
    #[doc = "The plugin MUST use this function to map any paths that will be stored"]
    #[doc = "in plugin state.  The returned value is an abstract path which MAY not"]
    #[doc = "be an actual file system path; absolute_path() MUST be used to map"]
    #[doc = "it to an actual path in order to use the file."]
    #[doc = ""]
    #[doc = "Plugins MUST NOT make any assumptions about abstract paths except that"]
    #[doc = "they can be mapped back to the absolute path of the \"same\" file (though"]
    #[doc = "not necessarily the same original path) using absolute_path()."]
    #[doc = ""]
    #[doc = "This function may only be called within the context of"]
    #[doc = "LV2_State_Interface methods.  The caller must free the returned value"]
    #[doc = "with LV2_State_Free_Path.free_path()."]
    pub abstract_path: ::std::option::Option<
        unsafe extern "C" fn(
            handle: LV2_State_Map_Path_Handle,
            absolute_path: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >,
    #[doc = "Map an abstract path from plugin state to an absolute path."]
    #[doc = "@param handle MUST be the `handle` member of this struct."]
    #[doc = "@param abstract_path An abstract path (typically from plugin state)."]
    #[doc = "@return An absolute file system path."]
    #[doc = ""]
    #[doc = "The plugin MUST use this function in order to actually open or otherwise"]
    #[doc = "use any paths loaded from plugin state."]
    #[doc = ""]
    #[doc = "This function may only be called within the context of"]
    #[doc = "LV2_State_Interface methods.  The caller must free the returned value"]
    #[doc = "with LV2_State_Free_Path.free_path()."]
    pub absolute_path: ::std::option::Option<
        unsafe extern "C" fn(
            handle: LV2_State_Map_Path_Handle,
            abstract_path: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >,
}
#[doc = "Feature data for state:makePath (@ref LV2_STATE__makePath)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_State_Make_Path {
    #[doc = "Opaque host data."]
    pub handle: LV2_State_Make_Path_Handle,
    #[doc = "Return a path the plugin may use to create a new file."]
    #[doc = "@param handle MUST be the `handle` member of this struct."]
    #[doc = "@param path The path of the new file within a namespace unique to this"]
    #[doc = "plugin instance."]
    #[doc = "@return The absolute path to use for the new file."]
    #[doc = ""]
    #[doc = "This function can be used by plugins to create files and directories,"]
    #[doc = "either at state saving time (if this feature is passed to"]
    #[doc = "LV2_State_Interface.save()) or any time (if this feature is passed to"]
    #[doc = "LV2_Descriptor.instantiate())."]
    #[doc = ""]
    #[doc = "The host MUST do whatever is necessary for the plugin to be able to"]
    #[doc = "create a file at the returned path (for example, using fopen()),"]
    #[doc = "including creating any leading directories."]
    #[doc = ""]
    #[doc = "If this function is passed to LV2_Descriptor.instantiate(), it may be"]
    #[doc = "called from any non-realtime context.  If it is passed to"]
    #[doc = "LV2_State_Interface.save(), it may only be called within the dynamic"]
    #[doc = "scope of that function call."]
    #[doc = ""]
    #[doc = "The caller must free the returned value with"]
    #[doc = "LV2_State_Free_Path.free_path()."]
    pub path: ::std::option::Option<
        unsafe extern "C" fn(
            handle: LV2_State_Make_Path_Handle,
            path: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >,
}
#[doc = "Feature data for state:freePath (@ref LV2_STATE__freePath)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_State_Free_Path {
    #[doc = "Opaque host data."]
    pub handle: LV2_State_Free_Path_Handle,
    #[doc = "Free a path returned by a state feature."]
    #[doc = ""]
    #[doc = "@param handle MUST be the `handle` member of this struct."]
    #[doc = "@param path The path previously returned by a state feature."]
    #[doc = ""]
    #[doc = "This function can be used by plugins to free paths allocated by the host"]
    #[doc = "and returned by state features (LV2_State_Map_Path.abstract_path(),"]
    #[doc = "LV2_State_Map_Path.absolute_path(), and LV2_State_Make_Path.path())."]
    pub free_path: ::std::option::Option<
        unsafe extern "C" fn(handle: LV2_State_Free_Path_Handle, path: *mut ::std::os::raw::c_char),
    >,
}
#[doc = "A pointer to some widget or other type of UI handle."]
#[doc = ""]
#[doc = "The actual type is defined by the type of the UI."]
pub type LV2UI_Widget = *mut ::std::os::raw::c_void;
#[doc = "A pointer to UI instance internals."]
#[doc = ""]
#[doc = "The host may compare this to NULL, but otherwise MUST NOT interpret it."]
pub type LV2UI_Handle = *mut ::std::os::raw::c_void;
#[doc = "A pointer to a controller provided by the host."]
#[doc = ""]
#[doc = "The UI may compare this to NULL, but otherwise MUST NOT interpret it."]
pub type LV2UI_Controller = *mut ::std::os::raw::c_void;
#[doc = "A pointer to opaque data for a feature."]
pub type LV2UI_Feature_Handle = *mut ::std::os::raw::c_void;
#[doc = "A host-provided function that sends data to a plugin's input ports."]
#[doc = ""]
#[doc = "@param controller The opaque controller pointer passed to"]
#[doc = "LV2UI_Descriptor::instantiate()."]
#[doc = ""]
#[doc = "@param port_index Index of the port to update."]
#[doc = ""]
#[doc = "@param buffer Buffer containing `buffer_size` bytes of data."]
#[doc = ""]
#[doc = "@param buffer_size Size of `buffer` in bytes."]
#[doc = ""]
#[doc = "@param port_protocol Either 0 or the URID for a ui:PortProtocol.  If 0, the"]
#[doc = "protocol is implicitly ui:floatProtocol, the port MUST be an lv2:ControlPort"]
#[doc = "input, `buffer` MUST point to a single float value, and `buffer_size` MUST"]
#[doc = "be sizeof(float).  The UI SHOULD NOT use a protocol not supported by the"]
#[doc = "host, but the host MUST gracefully ignore any protocol it does not"]
#[doc = "understand."]
pub type LV2UI_Write_Function = ::std::option::Option<
    unsafe extern "C" fn(
        controller: LV2UI_Controller,
        port_index: u32,
        buffer_size: u32,
        port_protocol: u32,
        buffer: *const ::std::os::raw::c_void,
    ),
>;
#[doc = "A plugin UI."]
#[doc = ""]
#[doc = "A pointer to an object of this type is returned by the lv2ui_descriptor()"]
#[doc = "function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2UI_Descriptor {
    #[doc = "The URI for this UI (not for the plugin it controls)."]
    pub URI: *const ::std::os::raw::c_char,
    #[doc = "Create a new UI and return a handle to it.  This function works"]
    #[doc = "similarly to LV2_Descriptor::instantiate()."]
    #[doc = ""]
    #[doc = "@param descriptor The descriptor for the UI to instantiate."]
    #[doc = ""]
    #[doc = "@param plugin_uri The URI of the plugin that this UI will control."]
    #[doc = ""]
    #[doc = "@param bundle_path The path to the bundle containing this UI, including"]
    #[doc = "the trailing directory separator."]
    #[doc = ""]
    #[doc = "@param write_function A function that the UI can use to send data to the"]
    #[doc = "plugin's input ports."]
    #[doc = ""]
    #[doc = "@param controller A handle for the UI instance to be passed as the"]
    #[doc = "first parameter of UI methods."]
    #[doc = ""]
    #[doc = "@param widget (output) widget pointer.  The UI points this at its main"]
    #[doc = "widget, which has the type defined by the UI type in the data file."]
    #[doc = ""]
    #[doc = "@param features An array of LV2_Feature pointers.  The host must pass"]
    #[doc = "all feature URIs that it and the UI supports and any additional data, as"]
    #[doc = "in LV2_Descriptor::instantiate().  Note that UI features and plugin"]
    #[doc = "features are not necessarily the same."]
    #[doc = ""]
    pub instantiate: ::std::option::Option<
        unsafe extern "C" fn(
            descriptor: *const LV2UI_Descriptor,
            plugin_uri: *const ::std::os::raw::c_char,
            bundle_path: *const ::std::os::raw::c_char,
            write_function: LV2UI_Write_Function,
            controller: LV2UI_Controller,
            widget: *mut LV2UI_Widget,
            features: *const *const LV2_Feature,
        ) -> LV2UI_Handle,
    >,
    #[doc = "Destroy the UI.  The host must not try to access the widget after"]
    #[doc = "calling this function."]
    pub cleanup: ::std::option::Option<unsafe extern "C" fn(ui: LV2UI_Handle)>,
    #[doc = "Tell the UI that something interesting has happened at a plugin port."]
    #[doc = ""]
    #[doc = "What is \"interesting\" and how it is written to `buffer` is defined by"]
    #[doc = "`format`, which has the same meaning as in LV2UI_Write_Function()."]
    #[doc = "Format 0 is a special case for lv2:ControlPort, where this function"]
    #[doc = "should be called when the port value changes (but not necessarily for"]
    #[doc = "every change), `buffer_size` must be sizeof(float), and `buffer`"]
    #[doc = "points to a single IEEE-754 float."]
    #[doc = ""]
    #[doc = "By default, the host should only call this function for lv2:ControlPort"]
    #[doc = "inputs.  However, the UI can request updates for other ports statically"]
    #[doc = "with ui:portNotification or dynamically with ui:portSubscribe."]
    #[doc = ""]
    #[doc = "The UI MUST NOT retain any reference to `buffer` after this function"]
    #[doc = "returns, it is only valid for the duration of the call."]
    #[doc = ""]
    #[doc = "This member may be NULL if the UI is not interested in any port events."]
    pub port_event: ::std::option::Option<
        unsafe extern "C" fn(
            ui: LV2UI_Handle,
            port_index: u32,
            buffer_size: u32,
            format: u32,
            buffer: *const ::std::os::raw::c_void,
        ),
    >,
    #[doc = "Return a data structure associated with an extension URI, typically an"]
    #[doc = "interface struct with additional function pointers"]
    #[doc = ""]
    #[doc = "This member may be set to NULL if the UI is not interested in supporting"]
    #[doc = "any extensions. This is similar to LV2_Descriptor::extension_data()."]
    #[doc = ""]
    pub extension_data: ::std::option::Option<
        unsafe extern "C" fn(uri: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_void,
    >,
}
#[doc = "Feature/interface for resizable UIs (LV2_UI__resize)."]
#[doc = ""]
#[doc = "This structure is used in two ways: as a feature passed by the host via"]
#[doc = "LV2UI_Descriptor::instantiate(), or as an interface provided by a UI via"]
#[doc = "LV2UI_Descriptor::extension_data())."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2UI_Resize {
    #[doc = "Pointer to opaque data which must be passed to ui_resize()."]
    pub handle: LV2UI_Feature_Handle,
    #[doc = "Request/advertise a size change."]
    #[doc = ""]
    #[doc = "When provided by the host, the UI may call this function to inform the"]
    #[doc = "host about the size of the UI."]
    #[doc = ""]
    #[doc = "When provided by the UI, the host may call this function to notify the"]
    #[doc = "UI that it should change its size accordingly.  In this case, the host"]
    #[doc = "must pass the LV2UI_Handle to provide access to the UI instance."]
    #[doc = ""]
    #[doc = "@return 0 on success."]
    pub ui_resize: ::std::option::Option<
        unsafe extern "C" fn(
            handle: LV2UI_Feature_Handle,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = "Feature to map port symbols to UIs."]
#[doc = ""]
#[doc = "This can be used by the UI to get the index for a port with the given"]
#[doc = "symbol.  This makes it possible to implement and distribute a UI separately"]
#[doc = "from the plugin (since symbol, unlike index, is a stable port identifier)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2UI_Port_Map {
    #[doc = "Pointer to opaque data which must be passed to port_index()."]
    pub handle: LV2UI_Feature_Handle,
    #[doc = "Get the index for the port with the given `symbol`."]
    #[doc = ""]
    #[doc = "@return The index of the port, or LV2UI_INVALID_PORT_INDEX if no such"]
    #[doc = "port is found."]
    pub port_index: ::std::option::Option<
        unsafe extern "C" fn(
            handle: LV2UI_Feature_Handle,
            symbol: *const ::std::os::raw::c_char,
        ) -> u32,
    >,
}
#[doc = "Feature to subscribe to port updates (LV2_UI__portSubscribe)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2UI_Port_Subscribe {
    #[doc = "Pointer to opaque data which must be passed to subscribe() and"]
    #[doc = "unsubscribe()."]
    pub handle: LV2UI_Feature_Handle,
    #[doc = "Subscribe to updates for a port."]
    #[doc = ""]
    #[doc = "This means that the host will call the UI's port_event() function when"]
    #[doc = "the port value changes (as defined by protocol)."]
    #[doc = ""]
    #[doc = "Calling this function with the same `port_index` and `port_protocol`"]
    #[doc = "as an already active subscription has no effect."]
    #[doc = ""]
    #[doc = "@param handle The handle field of this struct."]
    #[doc = "@param port_index The index of the port."]
    #[doc = "@param port_protocol The URID of the ui:PortProtocol."]
    #[doc = "@param features Features for this subscription."]
    #[doc = "@return 0 on success."]
    pub subscribe: ::std::option::Option<
        unsafe extern "C" fn(
            handle: LV2UI_Feature_Handle,
            port_index: u32,
            port_protocol: u32,
            features: *const *const LV2_Feature,
        ) -> u32,
    >,
    #[doc = "Unsubscribe from updates for a port."]
    #[doc = ""]
    #[doc = "This means that the host will cease calling calling port_event() when"]
    #[doc = "the port value changes."]
    #[doc = ""]
    #[doc = "Calling this function with a `port_index` and `port_protocol` that"]
    #[doc = "does not refer to an active port subscription has no effect."]
    #[doc = ""]
    #[doc = "@param handle The handle field of this struct."]
    #[doc = "@param port_index The index of the port."]
    #[doc = "@param port_protocol The URID of the ui:PortProtocol."]
    #[doc = "@param features Features for this subscription."]
    #[doc = "@return 0 on success."]
    pub unsubscribe: ::std::option::Option<
        unsafe extern "C" fn(
            handle: LV2UI_Feature_Handle,
            port_index: u32,
            port_protocol: u32,
            features: *const *const LV2_Feature,
        ) -> u32,
    >,
}
#[doc = "A feature to notify the host that the user has grabbed a UI control."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2UI_Touch {
    #[doc = "Pointer to opaque data which must be passed to touch()."]
    pub handle: LV2UI_Feature_Handle,
    #[doc = "Notify the host that a control has been grabbed or released."]
    #[doc = ""]
    #[doc = "The host should cease automating the port or otherwise manipulating the"]
    #[doc = "port value until the control has been ungrabbed."]
    #[doc = ""]
    #[doc = "@param handle The handle field of this struct."]
    #[doc = "@param port_index The index of the port associated with the control."]
    #[doc = "@param grabbed If true, the control has been grabbed, otherwise the"]
    #[doc = "control has been released."]
    pub touch: ::std::option::Option<
        unsafe extern "C" fn(handle: LV2UI_Feature_Handle, port_index: u32, grabbed: bool),
    >,
}
#[doc = "Completed successfully."]
#[doc = ""]
#[doc = "The host will set the parameter later if the user chooses a new value."]
pub const LV2UI_Request_Value_Status_LV2UI_REQUEST_VALUE_SUCCESS: LV2UI_Request_Value_Status = 0;
#[doc = "Parameter already being requested."]
#[doc = ""]
#[doc = "The host is already requesting a parameter from the user (for example, a"]
#[doc = "dialog is visible), or the UI is otherwise busy and can not make this"]
#[doc = "request."]
pub const LV2UI_Request_Value_Status_LV2UI_REQUEST_VALUE_BUSY: LV2UI_Request_Value_Status = 1;
#[doc = "Unknown parameter."]
#[doc = ""]
#[doc = "The host is not aware of this parameter, and is not able to set a new"]
#[doc = "value for it."]
pub const LV2UI_Request_Value_Status_LV2UI_REQUEST_VALUE_ERR_UNKNOWN: LV2UI_Request_Value_Status =
    2;
#[doc = "Unsupported parameter."]
#[doc = ""]
#[doc = "The host knows about this parameter, but does not support requesting a"]
#[doc = "new value for it from the user.  This is likely because the host does"]
#[doc = "not have UI support for choosing a value with the appropriate type."]
pub const LV2UI_Request_Value_Status_LV2UI_REQUEST_VALUE_ERR_UNSUPPORTED:
    LV2UI_Request_Value_Status = 3;
#[doc = "A status code for LV2UI_Request_Value::request()."]
pub type LV2UI_Request_Value_Status = ::std::os::raw::c_uint;
#[doc = "A feature to request a new parameter value from the host."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2UI_Request_Value {
    #[doc = "Pointer to opaque data which must be passed to request()."]
    pub handle: LV2UI_Feature_Handle,
    #[doc = "Request a value for a parameter from the host."]
    #[doc = ""]
    #[doc = "This is mainly used by UIs to request values for complex parameters that"]
    #[doc = "don't change often, such as file paths, but it may be used to request"]
    #[doc = "any parameter value."]
    #[doc = ""]
    #[doc = "This function returns immediately, and the return value indicates"]
    #[doc = "whether the host can fulfil the request.  The host may notify the"]
    #[doc = "plugin about the new parameter value, for example when a file is"]
    #[doc = "selected by the user, via the usual mechanism.  Typically, the host will"]
    #[doc = "send a message to the plugin that sets the new parameter value, and the"]
    #[doc = "plugin will notify the UI via a message as usual for any other parameter"]
    #[doc = "change."]
    #[doc = ""]
    #[doc = "To provide an appropriate UI, the host can determine details about the"]
    #[doc = "parameter from the plugin data as usual.  The additional parameters of"]
    #[doc = "this function provide support for more advanced use cases, but in the"]
    #[doc = "simple common case, the plugin will simply pass the key of the desired"]
    #[doc = "parameter and zero for everything else."]
    #[doc = ""]
    #[doc = "@param handle The handle field of this struct."]
    #[doc = ""]
    #[doc = "@param key The URID of the parameter."]
    #[doc = ""]
    #[doc = "@param type The optional type of the value to request.  This can be used"]
    #[doc = "to request a specific value type for parameters that support several."]
    #[doc = "If non-zero, it must be the URID of an instance of rdfs:Class or"]
    #[doc = "rdfs:Datatype."]
    #[doc = ""]
    #[doc = "@param features Additional features for this request, or NULL."]
    #[doc = ""]
    #[doc = "@return A status code which is 0 on success."]
    pub request: ::std::option::Option<
        unsafe extern "C" fn(
            handle: LV2UI_Feature_Handle,
            key: LV2_URID,
            type_: LV2_URID,
            features: *const *const LV2_Feature,
        ) -> LV2UI_Request_Value_Status,
    >,
}
#[doc = "UI Idle Interface (LV2_UI__idleInterface)"]
#[doc = ""]
#[doc = "UIs can provide this interface to have an idle() callback called by the host"]
#[doc = "rapidly to update the UI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2UI_Idle_Interface {
    #[doc = "Run a single iteration of the UI's idle loop."]
    #[doc = ""]
    #[doc = "This will be called rapidly in the UI thread at a rate appropriate"]
    #[doc = "for a toolkit main loop.  There are no precise timing guarantees, but"]
    #[doc = "the host should attempt to call idle() at a high enough rate for smooth"]
    #[doc = "animation, at least 30Hz."]
    #[doc = ""]
    #[doc = "@return non-zero if the UI has been closed, in which case the host"]
    #[doc = "should stop calling idle(), and can either completely destroy the UI, or"]
    #[doc = "re-show it and resume calling idle()."]
    pub idle:
        ::std::option::Option<unsafe extern "C" fn(ui: LV2UI_Handle) -> ::std::os::raw::c_int>,
}
#[doc = "UI Show Interface (LV2_UI__showInterface)"]
#[doc = ""]
#[doc = "UIs can provide this interface to show and hide a window, which allows them"]
#[doc = "to function in hosts unable to embed their widget.  This allows any UI to"]
#[doc = "provide a fallback for embedding that works in any host."]
#[doc = ""]
#[doc = "If used:"]
#[doc = "- The host MUST use LV2UI_Idle_Interface to drive the UI."]
#[doc = "- The UI MUST return non-zero from LV2UI_Idle_Interface::idle() when it has"]
#[doc = "been closed."]
#[doc = "- If idle() returns non-zero, the host MUST call hide() and stop calling"]
#[doc = "idle().  It MAY later call show() then resume calling idle()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2UI_Show_Interface {
    #[doc = "Show a window for this UI."]
    #[doc = ""]
    #[doc = "The window title MAY have been passed by the host to"]
    #[doc = "LV2UI_Descriptor::instantiate() as an LV2_Options_Option with key"]
    #[doc = "LV2_UI__windowTitle."]
    #[doc = ""]
    #[doc = "@return 0 on success, or anything else to stop being called."]
    pub show:
        ::std::option::Option<unsafe extern "C" fn(ui: LV2UI_Handle) -> ::std::os::raw::c_int>,
    #[doc = "Hide the window for this UI."]
    #[doc = ""]
    #[doc = "@return 0 on success, or anything else to stop being called."]
    pub hide:
        ::std::option::Option<unsafe extern "C" fn(ui: LV2UI_Handle) -> ::std::os::raw::c_int>,
}
#[doc = "Peak data for a slice of time, the update format for ui:peakProtocol."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2UI_Peak_Data {
    #[doc = "The start of the measurement period.  This is just a running counter"]
    #[doc = "that is only meaningful in comparison to previous values and must not be"]
    #[doc = "interpreted as an absolute time."]
    pub period_start: u32,
    #[doc = "The size of the measurement period, in the same units as period_start."]
    pub period_size: u32,
    #[doc = "The peak value for the measurement period. This should be the maximal"]
    #[doc = "value for abs(sample) over all the samples in the period."]
    pub peak: f32,
}
#[doc = "The type of the lv2ui_descriptor() function."]
pub type LV2UI_DescriptorFunction =
    ::std::option::Option<unsafe extern "C" fn(index: u32) -> *const LV2UI_Descriptor>;
#[doc = "Opaque pointer to host data."]
pub type LV2_URI_Map_Callback_Data = *mut ::std::os::raw::c_void;
#[doc = "URI Map Feature."]
#[doc = ""]
#[doc = "To support this feature the host must pass an LV2_Feature struct to the"]
#[doc = "plugin's instantiate method with URI \"http://lv2plug.in/ns/ext/uri-map\""]
#[doc = "and data pointed to an instance of this struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_URI_Map_Feature {
    #[doc = "Opaque pointer to host data."]
    #[doc = ""]
    #[doc = "The plugin MUST pass this to any call to functions in this struct."]
    #[doc = "Otherwise, it must not be interpreted in any way."]
    pub callback_data: LV2_URI_Map_Callback_Data,
    #[doc = "Get the numeric ID of a URI from the host."]
    #[doc = ""]
    #[doc = "@param callback_data Must be the callback_data member of this struct."]
    #[doc = "@param map The 'context' of this URI. Certain extensions may define a"]
    #[doc = "URI that must be passed here with certain restrictions on the return"]
    #[doc = "value (e.g. limited range). This value may be NULL if the plugin needs"]
    #[doc = "an ID for a URI in general. Extensions SHOULD NOT define a context"]
    #[doc = "unless there is a specific need to do so, e.g. to restrict the range of"]
    #[doc = "the returned value."]
    #[doc = "@param uri The URI to be mapped to an integer ID."]
    #[doc = ""]
    #[doc = "This function is referentially transparent; any number of calls with the"]
    #[doc = "same arguments is guaranteed to return the same value over the life of a"]
    #[doc = "plugin instance (though the same URI may return different values with a"]
    #[doc = "different map parameter). However, this function is not necessarily very"]
    #[doc = "fast: plugins SHOULD cache any IDs they might need in performance"]
    #[doc = "critical situations."]
    #[doc = ""]
    #[doc = "The return value 0 is reserved and indicates that an ID for that URI"]
    #[doc = "could not be created for whatever reason. Extensions MAY define more"]
    #[doc = "precisely what this means in a certain context, but in general plugins"]
    #[doc = "SHOULD handle this situation as gracefully as possible. However, hosts"]
    #[doc = "SHOULD NOT return 0 from this function in non-exceptional circumstances"]
    #[doc = "(e.g. the URI map SHOULD be dynamic). Hosts that statically support only"]
    #[doc = "a fixed set of URIs should not expect plugins to function correctly."]
    pub uri_to_id: ::std::option::Option<
        unsafe extern "C" fn(
            callback_data: LV2_URI_Map_Callback_Data,
            map: *const ::std::os::raw::c_char,
            uri: *const ::std::os::raw::c_char,
        ) -> u32,
    >,
}
#[doc = "< Completed successfully."]
pub const LV2_Worker_Status_LV2_WORKER_SUCCESS: LV2_Worker_Status = 0;
#[doc = "< Unknown error."]
pub const LV2_Worker_Status_LV2_WORKER_ERR_UNKNOWN: LV2_Worker_Status = 1;
#[doc = "< Failed due to lack of space."]
pub const LV2_Worker_Status_LV2_WORKER_ERR_NO_SPACE: LV2_Worker_Status = 2;
#[doc = "Status code for worker functions."]
pub type LV2_Worker_Status = ::std::os::raw::c_uint;
#[doc = " Opaque handle for LV2_Worker_Interface::work()."]
pub type LV2_Worker_Respond_Handle = *mut ::std::os::raw::c_void;
#[doc = "A function to respond to run() from the worker method."]
#[doc = ""]
#[doc = "The `data` MUST be safe for the host to copy and later pass to"]
#[doc = "work_response(), and the host MUST guarantee that it will be eventually"]
#[doc = "passed to work_response() if this function returns LV2_WORKER_SUCCESS."]
pub type LV2_Worker_Respond_Function = ::std::option::Option<
    unsafe extern "C" fn(
        handle: LV2_Worker_Respond_Handle,
        size: u32,
        data: *const ::std::os::raw::c_void,
    ) -> LV2_Worker_Status,
>;
#[doc = "Plugin Worker Interface."]
#[doc = ""]
#[doc = "This is the interface provided by the plugin to implement a worker method."]
#[doc = "The plugin's extension_data() method should return an LV2_Worker_Interface"]
#[doc = "when called with LV2_WORKER__interface as its argument."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Worker_Interface {
    #[doc = "The worker method.  This is called by the host in a non-realtime context"]
    #[doc = "as requested, possibly with an arbitrary message to handle."]
    #[doc = ""]
    #[doc = "A response can be sent to run() using `respond`.  The plugin MUST NOT"]
    #[doc = "make any assumptions about which thread calls this method, except that"]
    #[doc = "there are no real-time requirements and only one call may be executed at"]
    #[doc = "a time.  That is, the host MAY call this method from any non-real-time"]
    #[doc = "thread, but MUST NOT make concurrent calls to this method from several"]
    #[doc = "threads."]
    #[doc = ""]
    #[doc = "@param instance The LV2 instance this is a method on."]
    #[doc = "@param respond  A function for sending a response to run()."]
    #[doc = "@param handle   Must be passed to `respond` if it is called."]
    #[doc = "@param size     The size of `data`."]
    #[doc = "@param data     Data from run(), or NULL."]
    pub work: ::std::option::Option<
        unsafe extern "C" fn(
            instance: LV2_Handle,
            respond: LV2_Worker_Respond_Function,
            handle: LV2_Worker_Respond_Handle,
            size: u32,
            data: *const ::std::os::raw::c_void,
        ) -> LV2_Worker_Status,
    >,
    #[doc = "Handle a response from the worker.  This is called by the host in the"]
    #[doc = "run() context when a response from the worker is ready."]
    #[doc = ""]
    #[doc = "@param instance The LV2 instance this is a method on."]
    #[doc = "@param size     The size of `body`."]
    #[doc = "@param body     Message body, or NULL."]
    pub work_response: ::std::option::Option<
        unsafe extern "C" fn(
            instance: LV2_Handle,
            size: u32,
            body: *const ::std::os::raw::c_void,
        ) -> LV2_Worker_Status,
    >,
    #[doc = "Called when all responses for this cycle have been delivered."]
    #[doc = ""]
    #[doc = "Since work_response() may be called after run() finished, this provides"]
    #[doc = "a hook for code that must run after the cycle is completed."]
    #[doc = ""]
    #[doc = "This field may be NULL if the plugin has no use for it.  Otherwise, the"]
    #[doc = "host MUST call it after every run(), regardless of whether or not any"]
    #[doc = "responses were sent that cycle."]
    pub end_run:
        ::std::option::Option<unsafe extern "C" fn(instance: LV2_Handle) -> LV2_Worker_Status>,
}
#[doc = " Opaque handle for LV2_Worker_Schedule."]
pub type LV2_Worker_Schedule_Handle = *mut ::std::os::raw::c_void;
#[doc = "Schedule Worker Host Feature."]
#[doc = ""]
#[doc = "The host passes this feature to provide a schedule_work() function, which"]
#[doc = "the plugin can use to schedule a worker call from run()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Worker_Schedule {
    #[doc = "Opaque host data."]
    pub handle: LV2_Worker_Schedule_Handle,
    #[doc = "Request from run() that the host call the worker."]
    #[doc = ""]
    #[doc = "This function is in the audio threading class.  It should be called from"]
    #[doc = "run() to request that the host call the work() method in a non-realtime"]
    #[doc = "context with the given arguments."]
    #[doc = ""]
    #[doc = "This function is always safe to call from run(), but it is not"]
    #[doc = "guaranteed that the worker is actually called from a different thread."]
    #[doc = "In particular, when free-wheeling (for example, during offline"]
    #[doc = "rendering), the worker may be executed immediately.  This allows"]
    #[doc = "single-threaded processing with sample accuracy and avoids timing"]
    #[doc = "problems when run() is executing much faster or slower than real-time."]
    #[doc = ""]
    #[doc = "Plugins SHOULD be written in such a way that if the worker runs"]
    #[doc = "immediately, and responses from the worker are delivered immediately,"]
    #[doc = "the effect of the work takes place immediately with sample accuracy."]
    #[doc = ""]
    #[doc = "The `data` MUST be safe for the host to copy and later pass to work(),"]
    #[doc = "and the host MUST guarantee that it will be eventually passed to work()"]
    #[doc = "if this function returns LV2_WORKER_SUCCESS."]
    #[doc = ""]
    #[doc = "@param handle The handle field of this struct."]
    #[doc = "@param size   The size of `data`."]
    #[doc = "@param data   Message to pass to work(), or NULL."]
    pub schedule_work: ::std::option::Option<
        unsafe extern "C" fn(
            handle: LV2_Worker_Schedule_Handle,
            size: u32,
            data: *const ::std::os::raw::c_void,
        ) -> LV2_Worker_Status,
    >,
}
pub type __builtin_va_list = *mut ::std::os::raw::c_void;
